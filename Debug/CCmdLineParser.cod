; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	CCmdLineParser.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@PBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCmdLineParser@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCmdLineParser@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CCmdLineParser@@QAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDWord@CCmdLineParser@@QAEKPADK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFloat@CCmdLineParser@@QAEMPADM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@CCmdLineParser@@QAEPADPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0CCmdLineParser@@QAE@PAD@Z			; CCmdLineParser::CCmdLineParser
PUBLIC	?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA ; `CCmdLineParser::CCmdLineParser'::`2'::__LINE__Var
PUBLIC	??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@ ; `string'
PUBLIC	??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@ ; `string'
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
EXTRN	?Trim@@YAXPAD@Z:NEAR				; Trim
EXTRN	_strupr:NEAR
EXTRN	__assert:NEAR
EXTRN	_malloc:NEAR
;	COMDAT rtc$IMZ
; File c:\documents and settings\dom\my documents\_dev\ae\xlr8a\x7g\ccmdlineparser.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT ?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA DD 04H	; `CCmdLineParser::CCmdLineParser'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@
CONST	SEGMENT
??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@ DB 'c:\documen'
	DB	'ts and settings\dom\my documents\_dev\ae\xlr8a\x7g\ccmdlinepa'
	DB	'rser.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@
CONST	SEGMENT
??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@ DB 'm_nNameValues'
	DB	'<MAX_NAMEVALUES', 00H			; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0CCmdLineParser@@QAE@PAD@Z
_TEXT	SEGMENT
_bFoundValue$84974 = -2185
_bFoundName$84973 = -2173
_bFoundSep$84972 = -2161
_nLenTmpValue$ = -2152
_nLenTmpName$ = -2140
_szTmpValue$ = -2128
_szTmpName$ = -1096
_bBuildingValue$ = -57
_bBuildingName$ = -45
_c$ = -33
_i$ = -24
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_szCmdLine$ = 8
??0CCmdLineParser@@QAE@PAD@Z PROC NEAR			; CCmdLineParser::CCmdLineParser, COMDAT
; _this$ = ecx

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 09 00
	00		 sub	 esp, 2384		; 00000950H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b0 f6 ff
	ff		 lea	 edi, DWORD PTR [ebp-2384]
  00013	b9 54 02 00 00	 mov	 ecx, 596		; 00000254H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 5    : 	unsigned int i ;
; 6    : 	char		 c ;
; 7    : 	bool		 bBuildingName = false ;

  0002e	c6 45 d3 00	 mov	 BYTE PTR _bBuildingName$[ebp], 0

; 8    : 	bool		 bBuildingValue = false ;

  00032	c6 45 c7 00	 mov	 BYTE PTR _bBuildingValue$[ebp], 0

; 9    : 	char		 szTmpName[ 1024 ], szTmpValue[ 1024 ];
; 10   : 	int			 nLenTmpName = 0, nLenTmpValue = 0 ;

  00036	c7 85 a4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _nLenTmpName$[ebp], 0
  00040	c7 85 98 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _nLenTmpValue$[ebp], 0

; 11   : 	
; 12   : // init. members
; 13   : 	m_nNameValues = 0 ;

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 80 00 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1024], 0

; 14   : 
; 15   : // scan supplied command-line
; 16   : 	for( i=0 ; i < strlen( szCmdLine ) ; i++ )

  00057	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005e	eb 09		 jmp	 SHORT $L84969
$L84970:
  00060	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$L84969:
  00069	8b 45 08	 mov	 eax, DWORD PTR _szCmdLine$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _strlen
  00072	83 c4 04	 add	 esp, 4
  00075	39 45 e8	 cmp	 DWORD PTR _i$[ebp], eax
  00078	0f 83 08 02 00
	00		 jae	 $L84971

; 17   : 	{
; 18   : 		bool bFoundSep = false ;

  0007e	c6 85 8f f7 ff
	ff 00		 mov	 BYTE PTR _bFoundSep$84972[ebp], 0

; 19   : 		bool bFoundName = false ;

  00085	c6 85 83 f7 ff
	ff 00		 mov	 BYTE PTR _bFoundName$84973[ebp], 0

; 20   : 		bool bFoundValue = false ;

  0008c	c6 85 77 f7 ff
	ff 00		 mov	 BYTE PTR _bFoundValue$84974[ebp], 0

; 21   : 
; 22   : 		c = szCmdLine[ i ];

  00093	8b 45 08	 mov	 eax, DWORD PTR _szCmdLine$[ebp]
  00096	03 45 e8	 add	 eax, DWORD PTR _i$[ebp]
  00099	8a 08		 mov	 cl, BYTE PTR [eax]
  0009b	88 4d df	 mov	 BYTE PTR _c$[ebp], cl

; 23   : 
; 24   : 	// look for a separator char
; 25   : 		if( c == '/' /*|| c == '-'*/ )

  0009e	0f be 45 df	 movsx	 eax, BYTE PTR _c$[ebp]
  000a2	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000a5	0f 85 4e 01 00
	00		 jne	 $L84975

; 26   : 		{
; 27   : 		// have we got a name/value pair?
; 28   : 			if( nLenTmpName > 0 && nLenTmpValue > 0 )

  000ab	83 bd a4 f7 ff
	ff 00		 cmp	 DWORD PTR _nLenTmpName$[ebp], 0
  000b2	0f 8e 1e 01 00
	00		 jle	 $L84976
  000b8	83 bd 98 f7 ff
	ff 00		 cmp	 DWORD PTR _nLenTmpValue$[ebp], 0
  000bf	0f 8e 11 01 00
	00		 jle	 $L84976

; 29   : 			{
; 30   : 				szTmpName[ nLenTmpName ] = '\x0' ;

  000c5	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpName$[ebp]
  000cb	c6 84 05 b8 fb
	ff ff 00	 mov	 BYTE PTR _szTmpName$[ebp+eax], 0

; 31   : 				szTmpValue[ nLenTmpValue ] = '\x0' ;

  000d3	8b 85 98 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpValue$[ebp]
  000d9	c6 84 05 b0 f7
	ff ff 00	 mov	 BYTE PTR _szTmpValue$[ebp+eax], 0

; 32   : 				m_szNames[ m_nNameValues ] = (char*)malloc( nLenTmpName+1 );

  000e1	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpName$[ebp]
  000e7	83 c0 01	 add	 eax, 1
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _malloc
  000f0	83 c4 04	 add	 esp, 4
  000f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 33   : 				m_szValues[ m_nNameValues ] = (char*)malloc( nLenTmpValue+1 );

  00102	8b 85 98 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpValue$[ebp]
  00108	83 c0 01	 add	 eax, 1
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _malloc
  00111	83 c4 04	 add	 esp, 4
  00114	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	89 84 91 00 02
	00 00		 mov	 DWORD PTR [ecx+edx*4+512], eax

; 34   : 				Trim( szTmpName );

  00127	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?Trim@@YAXPAD@Z		; Trim
  00133	83 c4 04	 add	 esp, 4

; 35   : 				Trim( szTmpValue );

  00136	8d 85 b0 f7 ff
	ff		 lea	 eax, DWORD PTR _szTmpValue$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?Trim@@YAXPAD@Z		; Trim
  00142	83 c4 04	 add	 esp, 4

; 36   : 				strupr( szTmpName );

  00145	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _strupr
  00151	83 c4 04	 add	 esp, 4

; 37   : 				strcpy( m_szNames[ m_nNameValues ], szTmpName );

  00154	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  00164	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _strcpy
  00170	83 c4 08	 add	 esp, 8

; 38   : 				strcpy( m_szValues[ m_nNameValues ], szTmpValue );

  00173	8d 85 b0 f7 ff
	ff		 lea	 eax, DWORD PTR _szTmpValue$[ebp]
  00179	50		 push	 eax
  0017a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  00183	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00186	8b 8c 90 00 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+512]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _strcpy
  00193	83 c4 08	 add	 esp, 8

; 39   : 				m_nNameValues++ ;

  00196	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00199	8b 88 00 04 00
	00		 mov	 ecx, DWORD PTR [eax+1024]
  0019f	83 c1 01	 add	 ecx, 1
  001a2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001a5	89 8a 00 04 00
	00		 mov	 DWORD PTR [edx+1024], ecx

; 40   : 				assert( m_nNameValues<MAX_NAMEVALUES );

  001ab	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001ae	81 b8 00 04 00
	00 80 00 00 00	 cmp	 DWORD PTR [eax+1024], 128 ; 00000080H
  001b8	7c 1c		 jl	 SHORT $L84976
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA
  001c0	83 c1 24	 add	 ecx, 36			; 00000024H
  001c3	51		 push	 ecx
  001c4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@
  001c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@
  001ce	e8 00 00 00 00	 call	 __assert
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84976:

; 41   : 			}
; 42   : 
; 43   : 			bBuildingName = true ;

  001d6	c6 45 d3 01	 mov	 BYTE PTR _bBuildingName$[ebp], 1

; 44   : 			bBuildingValue = false ;

  001da	c6 45 c7 00	 mov	 BYTE PTR _bBuildingValue$[ebp], 0

; 45   : 			nLenTmpName = 0 ;

  001de	c7 85 a4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _nLenTmpName$[ebp], 0

; 46   : 			nLenTmpValue = 0 ;

  001e8	c7 85 98 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _nLenTmpValue$[ebp], 0

; 47   : 			bFoundSep = true ;

  001f2	c6 85 8f f7 ff
	ff 01		 mov	 BYTE PTR _bFoundSep$84972[ebp], 1
$L84975:

; 48   : 		}
; 49   : 		if( bFoundSep )

  001f9	0f b6 85 8f f7
	ff ff		 movzx	 eax, BYTE PTR _bFoundSep$84972[ebp]
  00200	85 c0		 test	 eax, eax
  00202	74 05		 je	 SHORT $L84983

; 50   : 			continue ;

  00204	e9 57 fe ff ff	 jmp	 $L84970
$L84983:

; 51   : 
; 52   : 	// build name
; 53   : 		if( bBuildingName )

  00209	0f b6 45 d3	 movzx	 eax, BYTE PTR _bBuildingName$[ebp]
  0020d	85 c0		 test	 eax, eax
  0020f	74 39		 je	 SHORT $L84984

; 54   : 			if( c == ':' )

  00211	0f be 45 df	 movsx	 eax, BYTE PTR _c$[ebp]
  00215	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00218	75 11		 jne	 SHORT $L84985

; 55   : 			{
; 56   : 				bBuildingName = false ;

  0021a	c6 45 d3 00	 mov	 BYTE PTR _bBuildingName$[ebp], 0

; 57   : 				bBuildingValue = true ;

  0021e	c6 45 c7 01	 mov	 BYTE PTR _bBuildingValue$[ebp], 1

; 58   : 				bFoundName = true ;

  00222	c6 85 83 f7 ff
	ff 01		 mov	 BYTE PTR _bFoundName$84973[ebp], 1

; 59   : 			}
; 60   : 			else

  00229	eb 1f		 jmp	 SHORT $L84984
$L84985:

; 61   : 				szTmpName[ nLenTmpName++ ] = c ;

  0022b	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpName$[ebp]
  00231	8a 4d df	 mov	 cl, BYTE PTR _c$[ebp]
  00234	88 8c 05 b8 fb
	ff ff		 mov	 BYTE PTR _szTmpName$[ebp+eax], cl
  0023b	8b 95 a4 f7 ff
	ff		 mov	 edx, DWORD PTR _nLenTmpName$[ebp]
  00241	83 c2 01	 add	 edx, 1
  00244	89 95 a4 f7 ff
	ff		 mov	 DWORD PTR _nLenTmpName$[ebp], edx
$L84984:

; 62   : 		if( bFoundName )

  0024a	0f b6 85 83 f7
	ff ff		 movzx	 eax, BYTE PTR _bFoundName$84973[ebp]
  00251	85 c0		 test	 eax, eax
  00253	74 05		 je	 SHORT $L84987

; 63   : 			continue ;

  00255	e9 06 fe ff ff	 jmp	 $L84970
$L84987:

; 64   : 
; 65   : 	// build value
; 66   : 		if( bBuildingValue )

  0025a	0f b6 45 c7	 movzx	 eax, BYTE PTR _bBuildingValue$[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	74 1f		 je	 SHORT $L84988

; 67   : 			szTmpValue[ nLenTmpValue++ ] = c ;

  00262	8b 85 98 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpValue$[ebp]
  00268	8a 4d df	 mov	 cl, BYTE PTR _c$[ebp]
  0026b	88 8c 05 b0 f7
	ff ff		 mov	 BYTE PTR _szTmpValue$[ebp+eax], cl
  00272	8b 95 98 f7 ff
	ff		 mov	 edx, DWORD PTR _nLenTmpValue$[ebp]
  00278	83 c2 01	 add	 edx, 1
  0027b	89 95 98 f7 ff
	ff		 mov	 DWORD PTR _nLenTmpValue$[ebp], edx
$L84988:

; 68   : 	}

  00281	e9 da fd ff ff	 jmp	 $L84970
$L84971:

; 69   : 
; 70   : // have we got a name/value pair?
; 71   : 	if( nLenTmpName > 0 && nLenTmpValue > 0 )

  00286	83 bd a4 f7 ff
	ff 00		 cmp	 DWORD PTR _nLenTmpName$[ebp], 0
  0028d	0f 8e 1e 01 00
	00		 jle	 $L84960
  00293	83 bd 98 f7 ff
	ff 00		 cmp	 DWORD PTR _nLenTmpValue$[ebp], 0
  0029a	0f 8e 11 01 00
	00		 jle	 $L84960

; 72   : 	{
; 73   : 		szTmpName[ nLenTmpName ] = '\x0' ;

  002a0	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpName$[ebp]
  002a6	c6 84 05 b8 fb
	ff ff 00	 mov	 BYTE PTR _szTmpName$[ebp+eax], 0

; 74   : 		szTmpValue[ nLenTmpValue ] = '\x0' ;

  002ae	8b 85 98 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpValue$[ebp]
  002b4	c6 84 05 b0 f7
	ff ff 00	 mov	 BYTE PTR _szTmpValue$[ebp+eax], 0

; 75   : 		m_szNames[ m_nNameValues ] = (char*)malloc( nLenTmpName+1 );

  002bc	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpName$[ebp]
  002c2	83 c0 01	 add	 eax, 1
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _malloc
  002cb	83 c4 04	 add	 esp, 4
  002ce	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002d1	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  002d7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002da	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 76   : 		m_szValues[ m_nNameValues ] = (char*)malloc( nLenTmpValue+1 );

  002dd	8b 85 98 f7 ff
	ff		 mov	 eax, DWORD PTR _nLenTmpValue$[ebp]
  002e3	83 c0 01	 add	 eax, 1
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _malloc
  002ec	83 c4 04	 add	 esp, 4
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f2	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  002f8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002fb	89 84 91 00 02
	00 00		 mov	 DWORD PTR [ecx+edx*4+512], eax

; 77   : 		Trim( szTmpName );

  00302	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 ?Trim@@YAXPAD@Z		; Trim
  0030e	83 c4 04	 add	 esp, 4

; 78   : 		Trim( szTmpValue );

  00311	8d 85 b0 f7 ff
	ff		 lea	 eax, DWORD PTR _szTmpValue$[ebp]
  00317	50		 push	 eax
  00318	e8 00 00 00 00	 call	 ?Trim@@YAXPAD@Z		; Trim
  0031d	83 c4 04	 add	 esp, 4

; 79   : 		strupr( szTmpName );

  00320	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _strupr
  0032c	83 c4 04	 add	 esp, 4

; 80   : 		strcpy( m_szNames[ m_nNameValues ], szTmpName );

  0032f	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _szTmpName$[ebp]
  00335	50		 push	 eax
  00336	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00339	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  0033f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00342	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 _strcpy
  0034b	83 c4 08	 add	 esp, 8

; 81   : 		strcpy( m_szValues[ m_nNameValues ], szTmpValue );

  0034e	8d 85 b0 f7 ff
	ff		 lea	 eax, DWORD PTR _szTmpValue$[ebp]
  00354	50		 push	 eax
  00355	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00358	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  0035e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00361	8b 8c 90 00 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+512]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 _strcpy
  0036e	83 c4 08	 add	 esp, 8

; 82   : 		m_nNameValues++ ;

  00371	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00374	8b 88 00 04 00
	00		 mov	 ecx, DWORD PTR [eax+1024]
  0037a	83 c1 01	 add	 ecx, 1
  0037d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00380	89 8a 00 04 00
	00		 mov	 DWORD PTR [edx+1024], ecx

; 83   : 		assert( m_nNameValues<MAX_NAMEVALUES );

  00386	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00389	81 b8 00 04 00
	00 80 00 00 00	 cmp	 DWORD PTR [eax+1024], 128 ; 00000080H
  00393	7c 1c		 jl	 SHORT $L84960
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1???0CCmdLineParser@@QAE@PAD@Z@4JA
  0039b	83 c1 4f	 add	 ecx, 79			; 0000004fH
  0039e	51		 push	 ecx
  0039f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FA@BEGJACPJ@c?3?2documents?5and?5settings?2dom?2my@
  003a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@NEOEAHJB@m_nNameValues?$DMMAX_NAMEVALUES?$AA@
  003a9	e8 00 00 00 00	 call	 __assert
  003ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84960:

; 84   : 	}
; 85   : }

  003b1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003b4	52		 push	 edx
  003b5	8b cd		 mov	 ecx, ebp
  003b7	50		 push	 eax
  003b8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85090
  003be	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003c3	58		 pop	 eax
  003c4	5a		 pop	 edx
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  003cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d0	5f		 pop	 edi
  003d1	5e		 pop	 esi
  003d2	5b		 pop	 ebx
  003d3	81 c4 50 09 00
	00		 add	 esp, 2384		; 00000950H
  003d9	3b ec		 cmp	 ebp, esp
  003db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e0	8b e5		 mov	 esp, ebp
  003e2	5d		 pop	 ebp
  003e3	c2 04 00	 ret	 4
$L85090:
  003e6	02 00 00 00	 DD	 2
  003ea	00 00 00 00	 DD	 $L85089
$L85089:
  003ee	b8 fb ff ff	 DD	 -1096			; fffffbb8H
  003f2	00 04 00 00	 DD	 1024			; 00000400H
  003f6	00 00 00 00	 DD	 $L85085
  003fa	b0 f7 ff ff	 DD	 -2128			; fffff7b0H
  003fe	00 04 00 00	 DD	 1024			; 00000400H
  00402	00 00 00 00	 DD	 $L85086
$L85086:
  00406	73		 DB	 115			; 00000073H
  00407	7a		 DB	 122			; 0000007aH
  00408	54		 DB	 84			; 00000054H
  00409	6d		 DB	 109			; 0000006dH
  0040a	70		 DB	 112			; 00000070H
  0040b	56		 DB	 86			; 00000056H
  0040c	61		 DB	 97			; 00000061H
  0040d	6c		 DB	 108			; 0000006cH
  0040e	75		 DB	 117			; 00000075H
  0040f	65		 DB	 101			; 00000065H
  00410	00		 DB	 0
$L85085:
  00411	73		 DB	 115			; 00000073H
  00412	7a		 DB	 122			; 0000007aH
  00413	54		 DB	 84			; 00000054H
  00414	6d		 DB	 109			; 0000006dH
  00415	70		 DB	 112			; 00000070H
  00416	4e		 DB	 78			; 0000004eH
  00417	61		 DB	 97			; 00000061H
  00418	6d		 DB	 109			; 0000006dH
  00419	65		 DB	 101			; 00000065H
  0041a	00		 DB	 0
??0CCmdLineParser@@QAE@PAD@Z ENDP			; CCmdLineParser::CCmdLineParser
_TEXT	ENDS
PUBLIC	??1CCmdLineParser@@QAE@XZ			; CCmdLineParser::~CCmdLineParser
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ??1CCmdLineParser@@QAE@XZ
_TEXT	SEGMENT
_i$ = -20
_this$ = -8
??1CCmdLineParser@@QAE@XZ PROC NEAR			; CCmdLineParser::~CCmdLineParser, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 89   : 	int i ;
; 90   : 	for( i=0 ; i < m_nNameValues ; i++ )

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002a	eb 09		 jmp	 SHORT $L84997
$L84998:
  0002c	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	83 c0 01	 add	 eax, 1
  00032	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$L84997:
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0003b	3b 88 00 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1024]
  00041	7d 2a		 jge	 SHORT $L84995

; 91   : 	{
; 92   : 		free( m_szNames[ i ] );

  00043	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4

; 93   : 		free( m_szValues[ i ] );

  00055	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8b 94 81 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+512]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _free
  00068	83 c4 04	 add	 esp, 4

; 94   : 	}

  0006b	eb bf		 jmp	 SHORT $L84998
$L84995:

; 95   : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
??1CCmdLineParser@@QAE@XZ ENDP				; CCmdLineParser::~CCmdLineParser
_TEXT	ENDS
PUBLIC	?GetInt@CCmdLineParser@@QAEHPADH@Z		; CCmdLineParser::GetInt
EXTRN	_atoi:NEAR
EXTRN	_strcmp:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?GetInt@CCmdLineParser@@QAEHPADH@Z
_TEXT	SEGMENT
_i$85006 = -1060
_szSearchFor$ = -1048
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_szName$ = 8
_Def$ = 12
?GetInt@CCmdLineParser@@QAEHPADH@Z PROC NEAR		; CCmdLineParser::GetInt, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1256]
  00013	b9 3a 01 00 00	 mov	 ecx, 314		; 0000013aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	char szSearchFor[ 1024 ];
; 100  : 	strcpy( szSearchFor, szName );

  0002e	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00031	50		 push	 eax
  00032	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szSearchFor$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	83 c4 08	 add	 esp, 8

; 101  : 	strupr( szSearchFor );

  00041	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strupr
  0004d	83 c4 04	 add	 esp, 4

; 102  : 	for( int i = 0 ; i < m_nNameValues ; i++ )

  00050	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$85006[ebp], 0
  0005a	eb 0f		 jmp	 SHORT $L85007
$L85008:
  0005c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85006[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 85 dc fb ff
	ff		 mov	 DWORD PTR _i$85006[ebp], eax
$L85007:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85006[ebp]
  00074	3b 88 00 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1024]
  0007a	7d 3d		 jge	 SHORT $L85009

; 103  : 		if( strcmp(m_szNames[ i ], szSearchFor) == 0 )

  0007c	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00082	50		 push	 eax
  00083	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85006[ebp]
  00089	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 1b		 jne	 SHORT $L85010

; 104  : 		{
; 105  : 			return atoi(m_szValues[ i ]) ;

  0009c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85006[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 94 81 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+512]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _atoi
  000b2	83 c4 04	 add	 esp, 4
  000b5	eb 05		 jmp	 SHORT $L85004
$L85010:

; 106  : 		}
; 107  : 	return Def ;

  000b7	eb a3		 jmp	 SHORT $L85008
$L85009:
  000b9	8b 45 0c	 mov	 eax, DWORD PTR _Def$[ebp]
$L85004:

; 108  : }

  000bc	52		 push	 edx
  000bd	8b cd		 mov	 ecx, ebp
  000bf	50		 push	 eax
  000c0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85104
  000c6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000cb	58		 pop	 eax
  000cc	5a		 pop	 edx
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d0	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	81 c4 e8 04 00
	00		 add	 esp, 1256		; 000004e8H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$L85104:
  000ee	01 00 00 00	 DD	 1
  000f2	00 00 00 00	 DD	 $L85103
$L85103:
  000f6	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  000fa	00 04 00 00	 DD	 1024			; 00000400H
  000fe	00 00 00 00	 DD	 $L85101
$L85101:
  00102	73		 DB	 115			; 00000073H
  00103	7a		 DB	 122			; 0000007aH
  00104	53		 DB	 83			; 00000053H
  00105	65		 DB	 101			; 00000065H
  00106	61		 DB	 97			; 00000061H
  00107	72		 DB	 114			; 00000072H
  00108	63		 DB	 99			; 00000063H
  00109	68		 DB	 104			; 00000068H
  0010a	46		 DB	 70			; 00000046H
  0010b	6f		 DB	 111			; 0000006fH
  0010c	72		 DB	 114			; 00000072H
  0010d	00		 DB	 0
?GetInt@CCmdLineParser@@QAEHPADH@Z ENDP			; CCmdLineParser::GetInt
_TEXT	ENDS
PUBLIC	?GetDWord@CCmdLineParser@@QAEKPADK@Z		; CCmdLineParser::GetDWord
EXTRN	_atol:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?GetDWord@CCmdLineParser@@QAEKPADK@Z
_TEXT	SEGMENT
_i$85017 = -1060
_szSearchFor$ = -1048
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_szName$ = 8
_Def$ = 12
?GetDWord@CCmdLineParser@@QAEKPADK@Z PROC NEAR		; CCmdLineParser::GetDWord, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1256]
  00013	b9 3a 01 00 00	 mov	 ecx, 314		; 0000013aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	char szSearchFor[ 1024 ];
; 113  : 	strcpy( szSearchFor, szName );

  0002e	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00031	50		 push	 eax
  00032	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szSearchFor$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	83 c4 08	 add	 esp, 8

; 114  : 	strupr( szSearchFor );

  00041	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strupr
  0004d	83 c4 04	 add	 esp, 4

; 115  : 	for( int i = 0 ; i < m_nNameValues ; i++ )

  00050	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$85017[ebp], 0
  0005a	eb 0f		 jmp	 SHORT $L85018
$L85019:
  0005c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85017[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 85 dc fb ff
	ff		 mov	 DWORD PTR _i$85017[ebp], eax
$L85018:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85017[ebp]
  00074	3b 88 00 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1024]
  0007a	7d 3d		 jge	 SHORT $L85020

; 116  : 		if( strcmp(m_szNames[ i ], szSearchFor) == 0 )

  0007c	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00082	50		 push	 eax
  00083	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85017[ebp]
  00089	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 1b		 jne	 SHORT $L85021

; 117  : 		{
; 118  : 			return (DWORD)atol(m_szValues[ i ]) ;

  0009c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85017[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 94 81 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+512]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _atol
  000b2	83 c4 04	 add	 esp, 4
  000b5	eb 05		 jmp	 SHORT $L85015
$L85021:

; 119  : 		}
; 120  : 	return Def ;

  000b7	eb a3		 jmp	 SHORT $L85019
$L85020:
  000b9	8b 45 0c	 mov	 eax, DWORD PTR _Def$[ebp]
$L85015:

; 121  : }

  000bc	52		 push	 edx
  000bd	8b cd		 mov	 ecx, ebp
  000bf	50		 push	 eax
  000c0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85111
  000c6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000cb	58		 pop	 eax
  000cc	5a		 pop	 edx
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d0	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	81 c4 e8 04 00
	00		 add	 esp, 1256		; 000004e8H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$L85111:
  000ee	01 00 00 00	 DD	 1
  000f2	00 00 00 00	 DD	 $L85110
$L85110:
  000f6	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  000fa	00 04 00 00	 DD	 1024			; 00000400H
  000fe	00 00 00 00	 DD	 $L85108
$L85108:
  00102	73		 DB	 115			; 00000073H
  00103	7a		 DB	 122			; 0000007aH
  00104	53		 DB	 83			; 00000053H
  00105	65		 DB	 101			; 00000065H
  00106	61		 DB	 97			; 00000061H
  00107	72		 DB	 114			; 00000072H
  00108	63		 DB	 99			; 00000063H
  00109	68		 DB	 104			; 00000068H
  0010a	46		 DB	 70			; 00000046H
  0010b	6f		 DB	 111			; 0000006fH
  0010c	72		 DB	 114			; 00000072H
  0010d	00		 DB	 0
?GetDWord@CCmdLineParser@@QAEKPADK@Z ENDP		; CCmdLineParser::GetDWord
_TEXT	ENDS
PUBLIC	?GetFloat@CCmdLineParser@@QAEMPADM@Z		; CCmdLineParser::GetFloat
EXTRN	__fltused:NEAR
EXTRN	_atof:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?GetFloat@CCmdLineParser@@QAEMPADM@Z
_TEXT	SEGMENT
tv128 = -1260
_i$85029 = -1060
_szSearchFor$ = -1048
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_szName$ = 8
_Def$ = 12
?GetFloat@CCmdLineParser@@QAEMPADM@Z PROC NEAR		; CCmdLineParser::GetFloat, COMDAT
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 04 00
	00		 sub	 esp, 1260		; 000004ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1260]
  00013	b9 3b 01 00 00	 mov	 ecx, 315		; 0000013bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	char szSearchFor[ 1024 ];
; 126  : 	strcpy( szSearchFor, szName );

  0002e	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00031	50		 push	 eax
  00032	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szSearchFor$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	83 c4 08	 add	 esp, 8

; 127  : 	strupr( szSearchFor );

  00041	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strupr
  0004d	83 c4 04	 add	 esp, 4

; 128  : 	for( int i = 0 ; i < m_nNameValues ; i++ )

  00050	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$85029[ebp], 0
  0005a	eb 0f		 jmp	 SHORT $L85030
$L85031:
  0005c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85029[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 85 dc fb ff
	ff		 mov	 DWORD PTR _i$85029[ebp], eax
$L85030:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85029[ebp]
  00074	3b 88 00 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1024]
  0007a	7d 43		 jge	 SHORT $L85032

; 129  : 		if( strcmp(m_szNames[ i ], szSearchFor) == 0 )

  0007c	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00082	50		 push	 eax
  00083	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85029[ebp]
  00089	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 21		 jne	 SHORT $L85033

; 130  : 		{
; 131  : 			return (float)atof(m_szValues[ i ]);

  0009c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85029[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 94 81 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+512]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _atof
  000b2	83 c4 04	 add	 esp, 4
  000b5	d9 95 14 fb ff
	ff		 fst	 DWORD PTR tv128[ebp]
  000bb	eb 05		 jmp	 SHORT $L85027
$L85033:

; 132  : 		}
; 133  : 	return Def ;

  000bd	eb 9d		 jmp	 SHORT $L85031
$L85032:
  000bf	d9 45 0c	 fld	 DWORD PTR _Def$[ebp]
$L85027:

; 134  : }

  000c2	52		 push	 edx
  000c3	8b cd		 mov	 ecx, ebp
  000c5	50		 push	 eax
  000c6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85118
  000cc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d1	58		 pop	 eax
  000d2	5a		 pop	 edx
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	81 c4 ec 04 00
	00		 add	 esp, 1260		; 000004ecH
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 08 00	 ret	 8
$L85118:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $L85117
$L85117:
  000fc	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  00100	00 04 00 00	 DD	 1024			; 00000400H
  00104	00 00 00 00	 DD	 $L85115
$L85115:
  00108	73		 DB	 115			; 00000073H
  00109	7a		 DB	 122			; 0000007aH
  0010a	53		 DB	 83			; 00000053H
  0010b	65		 DB	 101			; 00000065H
  0010c	61		 DB	 97			; 00000061H
  0010d	72		 DB	 114			; 00000072H
  0010e	63		 DB	 99			; 00000063H
  0010f	68		 DB	 104			; 00000068H
  00110	46		 DB	 70			; 00000046H
  00111	6f		 DB	 111			; 0000006fH
  00112	72		 DB	 114			; 00000072H
  00113	00		 DB	 0
?GetFloat@CCmdLineParser@@QAEMPADM@Z ENDP		; CCmdLineParser::GetFloat
_TEXT	ENDS
PUBLIC	?GetString@CCmdLineParser@@QAEPADPAD0@Z		; CCmdLineParser::GetString
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?GetString@CCmdLineParser@@QAEPADPAD0@Z
_TEXT	SEGMENT
_i$85041 = -1060
_szSearchFor$ = -1048
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_szName$ = 8
_Def$ = 12
?GetString@CCmdLineParser@@QAEPADPAD0@Z PROC NEAR	; CCmdLineParser::GetString, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1256]
  00013	b9 3a 01 00 00	 mov	 ecx, 314		; 0000013aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 138  : 	char szSearchFor[ 1024 ];
; 139  : 	strcpy( szSearchFor, szName );

  0002e	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00031	50		 push	 eax
  00032	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _szSearchFor$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	83 c4 08	 add	 esp, 8

; 140  : 	strupr( szSearchFor );

  00041	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strupr
  0004d	83 c4 04	 add	 esp, 4

; 141  : 	for( int i = 0 ; i < m_nNameValues ; i++ )

  00050	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$85041[ebp], 0
  0005a	eb 0f		 jmp	 SHORT $L85042
$L85043:
  0005c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85041[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 85 dc fb ff
	ff		 mov	 DWORD PTR _i$85041[ebp], eax
$L85042:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85041[ebp]
  00074	3b 88 00 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1024]
  0007a	7d 34		 jge	 SHORT $L85044

; 142  : 		if( strcmp(m_szNames[ i ], szSearchFor) == 0 )

  0007c	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _szSearchFor$[ebp]
  00082	50		 push	 eax
  00083	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _i$85041[ebp]
  00089	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _strcmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 12		 jne	 SHORT $L85045

; 143  : 		{
; 144  : 			return m_szValues[ i ];

  0009c	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _i$85041[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 84 81 00 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+512]
  000ac	eb 05		 jmp	 SHORT $L85039
$L85045:

; 145  : 		}
; 146  : 	return Def ;

  000ae	eb ac		 jmp	 SHORT $L85043
$L85044:
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _Def$[ebp]
$L85039:

; 147  : }

  000b3	52		 push	 edx
  000b4	8b cd		 mov	 ecx, ebp
  000b6	50		 push	 eax
  000b7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85126
  000bd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c2	58		 pop	 eax
  000c3	5a		 pop	 edx
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	81 c4 e8 04 00
	00		 add	 esp, 1256		; 000004e8H
  000d8	3b ec		 cmp	 ebp, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 08 00	 ret	 8
$L85126:
  000e5	01 00 00 00	 DD	 1
  000e9	00 00 00 00	 DD	 $L85125
$L85125:
  000ed	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  000f1	00 04 00 00	 DD	 1024			; 00000400H
  000f5	00 00 00 00	 DD	 $L85123
$L85123:
  000f9	73		 DB	 115			; 00000073H
  000fa	7a		 DB	 122			; 0000007aH
  000fb	53		 DB	 83			; 00000053H
  000fc	65		 DB	 101			; 00000065H
  000fd	61		 DB	 97			; 00000061H
  000fe	72		 DB	 114			; 00000072H
  000ff	63		 DB	 99			; 00000063H
  00100	68		 DB	 104			; 00000068H
  00101	46		 DB	 70			; 00000046H
  00102	6f		 DB	 111			; 0000006fH
  00103	72		 DB	 114			; 00000072H
  00104	00		 DB	 0
?GetString@CCmdLineParser@@QAEPADPAD0@Z ENDP		; CCmdLineParser::GetString
_TEXT	ENDS
END
