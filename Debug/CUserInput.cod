; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	CUserInput.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@PBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CUserInput@@QAE@PAUHWND__@@_NM11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserInput@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CUserInput@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Poll@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PollJoystick@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PollKeyboard@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PollMouse@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PollMouseSticky@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0CUserInput@@QAE@PAUHWND__@@_NM11@Z		; CUserInput::CUserInput
PUBLIC	?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z ; EnumJoysticksCallback
PUBLIC	?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z ; EnumAxesCallback
PUBLIC	?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA ; `CUserInput::CUserInput'::`2'::__LINE__Var
PUBLIC	??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@ ; `string'
PUBLIC	??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@	; `string'
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	__fltused:NEAR
EXTRN	_c_dfDIMouse:BYTE
EXTRN	_c_dfDIKeyboard:BYTE
EXTRN	_c_dfDIJoystick:BYTE
EXTRN	__assert:NEAR
EXTRN	__imp__GetModuleHandleA@4:NEAR
EXTRN	_DirectInput8Create@20:NEAR
EXTRN	_IID_IDirectInput8A:BYTE
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
;	COMDAT rtc$IMZ
; File c:\documents and settings\dom\my documents\_dev\ae\xlr8a\x7g\cuserinput.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA DD 0fH ; `CUserInput::CUserInput'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
CONST	SEGMENT
??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@ DB 'c:\documen'
	DB	'ts and settings\dom\my documents\_dev\ae\xlr8a\x7g\cuserinput'
	DB	'.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@ DB '!FAILED(hr)', 00H ; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0CUserInput@@QAE@PAUHWND__@@_NM11@Z
_TEXT	SEGMENT
$T85085 = -244
_i$ = -32
_hr$ = -20
_this$ = -8
_hWnd$ = 8
_bNonStickyMouse$ = 12
_fMouseSensitivity$ = 16
_bMouseInvert$ = 20
_bMouseExclusive$ = 24
??0CUserInput@@QAE@PAUHWND__@@_NM11@Z PROC NEAR		; CUserInput::CUserInput, COMDAT
; _this$ = ecx

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00013	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??0D3DXVECTOR3@@QAE@XZ ; D3DXVECTOR3::D3DXVECTOR3
  00028	6a 01		 push	 1
  0002a	6a 0c		 push	 12			; 0000000cH
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	05 44 06 00 00	 add	 eax, 1604		; 00000644H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z

; 16   : 		HRESULT hr ;
; 17   : 		int i ;
; 18   : 
; 19   : 		m_pDI = NULL ;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 20   : 		m_pKeyboard = NULL ;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 21   : 		m_pMouse = NULL ;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 80 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1600], 0

; 22   : 		m_pJoystick = NULL ;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 80 8c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1676], 0

; 23   : 
; 24   : 		hr = DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&m_pDI, NULL);

  00067	6a 00		 push	 0
  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectInput8A
  00072	68 00 08 00 00	 push	 2048			; 00000800H
  00077	8b f4		 mov	 esi, esp
  00079	6a 00		 push	 0
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _DirectInput8Create@20
  0008e	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 25   : 		assert( !FAILED(hr) );

  00091	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00095	7d 1b		 jge	 SHORT $L85078
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  0009c	83 c0 0a	 add	 eax, 10			; 0000000aH
  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  000aa	e8 00 00 00 00	 call	 __assert
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85078:

; 26   :     
; 27   : 	//
; 28   : 	// Keyboard:
; 29   : 	//
; 30   : 		hr = m_pDI->CreateDevice(GUID_SysKeyboard, &m_pKeyboard, NULL);

  000b2	8b f4		 mov	 esi, esp
  000b4	6a 00		 push	 0
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 04	 add	 eax, 4
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_SysKeyboard
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 12		 mov	 edx, DWORD PTR [edx]
  000ce	51		 push	 ecx
  000cf	ff 52 0c	 call	 DWORD PTR [edx+12]
  000d2	3b f4		 cmp	 esi, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 31   : 		assert( !FAILED(hr) );

  000dc	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e0	7d 1b		 jge	 SHORT $L85079
  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  000e7	83 c0 10	 add	 eax, 16			; 00000010H
  000ea	50		 push	 eax
  000eb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  000f5	e8 00 00 00 00	 call	 __assert
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85079:

; 32   : 		hr = m_pKeyboard->SetDataFormat(&c_dfDIKeyboard);

  000fd	8b f4		 mov	 esi, esp
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:_c_dfDIKeyboard
  00104	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00110	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00112	50		 push	 eax
  00113	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00116	3b f4		 cmp	 esi, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 33   : 		assert( !FAILED(hr) );

  00120	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00124	7d 1b		 jge	 SHORT $L85080
  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  0012b	83 c0 12	 add	 eax, 18			; 00000012H
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  00134	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  00139	e8 00 00 00 00	 call	 __assert
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85080:

; 34   : 		hr = m_pKeyboard->SetCooperativeLevel(hWnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);

  00141	8b f4		 mov	 esi, esp
  00143	6a 06		 push	 6
  00145	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00148	50		 push	 eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0014f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00155	8b 12		 mov	 edx, DWORD PTR [edx]
  00157	51		 push	 ecx
  00158	ff 52 34	 call	 DWORD PTR [edx+52]
  0015b	3b f4		 cmp	 esi, esp
  0015d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00162	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 35   : 		assert( !FAILED(hr) );

  00165	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00169	7d 1b		 jge	 SHORT $L85081
  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  00170	83 c0 14	 add	 eax, 20			; 00000014H
  00173	50		 push	 eax
  00174	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  00179	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  0017e	e8 00 00 00 00	 call	 __assert
  00183	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85081:

; 36   : 		m_pKeyboard->Acquire() ;

  00186	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00189	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0018f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00192	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00194	8b f4		 mov	 esi, esp
  00196	50		 push	 eax
  00197	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0019a	3b f4		 cmp	 esi, esp
  0019c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 37   : 		for (i = 0 ; i < 256 ; i ++) // single-key detection

  001a1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001a8	eb 09		 jmp	 SHORT $L84757
$L84758:
  001aa	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  001ad	83 c0 01	 add	 eax, 1
  001b0	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L84757:
  001b3	81 7d e0 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  001ba	7d 13		 jge	 SHORT $L84759

; 38   : 			m_bKB_Pressed[i] = FALSE ;

  001bc	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  001bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c2	c7 84 81 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+520], 0
  001cd	eb db		 jmp	 SHORT $L84758
$L84759:

; 39   : 		m_bGotPrevKBBuf = FALSE ;

  001cf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	c7 80 08 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1544], 0

; 40   : 
; 41   : 	//
; 42   : 	// Mouse:
; 43   : 	//
; 44   : 		hr = m_pDI->CreateDevice(GUID_SysMouse, &m_pMouse, NULL);

  001dc	8b f4		 mov	 esi, esp
  001de	6a 00		 push	 0
  001e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e3	05 40 06 00 00	 add	 eax, 1600		; 00000640H
  001e8	50		 push	 eax
  001e9	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_SysMouse
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f8	8b 12		 mov	 edx, DWORD PTR [edx]
  001fa	51		 push	 ecx
  001fb	ff 52 0c	 call	 DWORD PTR [edx+12]
  001fe	3b f4		 cmp	 esi, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 45   : 		assert( !FAILED(hr) );

  00208	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0020c	7d 1b		 jge	 SHORT $L85082
  0020e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  00213	83 c0 1e	 add	 eax, 30			; 0000001eH
  00216	50		 push	 eax
  00217	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  0021c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  00221	e8 00 00 00 00	 call	 __assert
  00226	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85082:

; 46   : 		hr = m_pMouse->SetDataFormat(&c_dfDIMouse);

  00229	8b f4		 mov	 esi, esp
  0022b	68 00 00 00 00	 push	 OFFSET FLAT:_c_dfDIMouse
  00230	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00233	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  00239	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0023c	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00242	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00244	50		 push	 eax
  00245	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00248	3b f4		 cmp	 esi, esp
  0024a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024f	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 47   : 		assert( !FAILED(hr) );

  00252	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00256	7d 1b		 jge	 SHORT $L85083
  00258	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  0025d	83 c0 20	 add	 eax, 32			; 00000020H
  00260	50		 push	 eax
  00261	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  00266	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  0026b	e8 00 00 00 00	 call	 __assert
  00270	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85083:

; 48   : 		hr = m_pMouse->SetCooperativeLevel( hWnd,
; 49   : 											DISCL_FOREGROUND |
; 50   : 											  ( bMouseExclusive ? DISCL_EXCLUSIVE : DISCL_NONEXCLUSIVE ) );

  00273	0f b6 45 18	 movzx	 eax, BYTE PTR _bMouseExclusive$[ebp]
  00277	f7 d8		 neg	 eax
  00279	1b c0		 sbb	 eax, eax
  0027b	83 c0 02	 add	 eax, 2
  0027e	83 c8 04	 or	 eax, 4
  00281	8b f4		 mov	 esi, esp
  00283	50		 push	 eax
  00284	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00287	51		 push	 ecx
  00288	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0028b	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00291	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00294	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  0029a	8b 00		 mov	 eax, DWORD PTR [eax]
  0029c	52		 push	 edx
  0029d	ff 50 34	 call	 DWORD PTR [eax+52]
  002a0	3b f4		 cmp	 esi, esp
  002a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a7	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 51   : 		assert( !FAILED(hr) );

  002aa	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ae	7d 1b		 jge	 SHORT $L85084
  002b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  002b5	83 c0 24	 add	 eax, 36			; 00000024H
  002b8	50		 push	 eax
  002b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  002be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  002c3	e8 00 00 00 00	 call	 __assert
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85084:

; 52   : 				/*DIPROPDWORD dipdw ;
; 53   : 				// BUFFERED
; 54   : 				dipdw.diph.dwSize       = sizeof(DIPROPDWORD) ;
; 55   : 				dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER) ;
; 56   : 				dipdw.diph.dwObj        = 0 ;
; 57   : 				dipdw.diph.dwHow        = DIPH_DEVICE ;
; 58   : 				dipdw.dwData            = MOUSE_BUFFER_SIZE ;
; 59   : 				if (FAILED(hr = m_pMouse->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph)))
; 60   : 					Msg("CUserInput::CUserInput(): FAILED(m_pMouse->SetProperty(...)) == TRUE") ;*/
; 61   : 		m_pMouse->Acquire() ;

  002cb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002ce	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  002d4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002d7	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  002dd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002df	8b f4		 mov	 esi, esp
  002e1	50		 push	 eax
  002e2	ff 51 1c	 call	 DWORD PTR [ecx+28]
  002e5	3b f4		 cmp	 esi, esp
  002e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   : 		for (i = 0 ; i < MOUSE_HISTORY_BUF ; i ++) // mouse-smoothing buffer

  002ec	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002f3	eb 09		 jmp	 SHORT $L84766
$L84767:
  002f5	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  002f8	83 c0 01	 add	 eax, 1
  002fb	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$L84766:
  002fe	83 7d e0 01	 cmp	 DWORD PTR _i$[ebp], 1
  00302	7d 33		 jge	 SHORT $L84768

; 63   : 			m_vMouseHistory[i] = xVec3( 0,0,0 );

  00304	6a 00		 push	 0
  00306	6a 00		 push	 0
  00308	6a 00		 push	 0
  0030a	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T85085[ebp]
  00310	e8 00 00 00 00	 call	 ??0D3DXVECTOR3@@QAE@MMM@Z ; D3DXVECTOR3::D3DXVECTOR3
  00315	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00318	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0031b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0031e	8d 8c 0a 44 06
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1604]
  00325	8b 10		 mov	 edx, DWORD PTR [eax]
  00327	89 11		 mov	 DWORD PTR [ecx], edx
  00329	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0032c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0032f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00332	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00335	eb be		 jmp	 SHORT $L84767
$L84768:

; 64   : 		m_fMousePrevZ = 0 ;

  00337	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0033a	c7 80 50 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1616], 0

; 65   : 		m_bScanForChangeInMouseWheel = TRUE ;

  00344	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00347	c7 80 70 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1648], 1

; 66   : 
; 67   : 		m_fMouseStickyX = m_fMouseStickyY = m_fMouseStickyZ = 0 ;

  00351	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00354	c7 80 7c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1660], 0
  0035e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00361	c7 81 78 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1656], 0
  0036b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0036e	c7 82 74 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1652], 0

; 68   : 		m_bNonStickyMouse = bNonStickyMouse ;

  00378	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0037b	8a 4d 0c	 mov	 cl, BYTE PTR _bNonStickyMouse$[ebp]
  0037e	88 88 80 06 00
	00		 mov	 BYTE PTR [eax+1664], cl

; 69   : 		m_fMouseSensitivity = fMouseSensitivity ;

  00384	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00387	8b 4d 10	 mov	 ecx, DWORD PTR _fMouseSensitivity$[ebp]
  0038a	89 88 84 06 00
	00		 mov	 DWORD PTR [eax+1668], ecx

; 70   : 		m_bMouseInvert = bMouseInvert ;

  00390	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00393	8a 4d 14	 mov	 cl, BYTE PTR _bMouseInvert$[ebp]
  00396	88 88 88 06 00
	00		 mov	 BYTE PTR [eax+1672], cl

; 71   : 
; 72   : 	//
; 73   : 	// Joystick:
; 74   : 	// (just uses first attached stick)
; 75   : 	//
; 76   : 		m_bJoystickPresent = FALSE ;

  0039c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0039f	c7 80 90 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1680], 0

; 77   : 		m_szJoystickProductName[0] = '\x0';

  003a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003ac	c6 80 a8 07 00
	00 00		 mov	 BYTE PTR [eax+1960], 0

; 78   : 		m_szJoystickInstanceName[0] = '\x0';

  003b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003b6	c6 80 a4 06 00
	00 00		 mov	 BYTE PTR [eax+1700], 0

; 79   : 		m_pDI->EnumDevices(DI8DEVCLASS_GAMECTRL, 
; 80   : 						   EnumJoysticksCallback, 
; 81   : 						   this, 
; 82   : 						   DIEDFL_ATTACHEDONLY) ;

  003bd	8b f4		 mov	 esi, esp
  003bf	6a 01		 push	 1
  003c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c4	50		 push	 eax
  003c5	68 00 00 00 00	 push	 OFFSET FLAT:?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z ; EnumJoysticksCallback
  003ca	6a 04		 push	 4
  003cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d6	8b 12		 mov	 edx, DWORD PTR [edx]
  003d8	51		 push	 ecx
  003d9	ff 52 10	 call	 DWORD PTR [edx+16]
  003dc	3b f4		 cmp	 esi, esp
  003de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 83   : 		if (m_bJoystickPresent)

  003e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e6	83 b8 90 06 00
	00 00		 cmp	 DWORD PTR [eax+1680], 0
  003ed	0f 84 58 01 00
	00		 je	 $L84741

; 84   : 		{
; 85   : 			hr = m_pDI->CreateDevice(m_guidJoystick, &m_pJoystick, NULL);

  003f3	8b f4		 mov	 esi, esp
  003f5	6a 00		 push	 0
  003f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003fa	05 8c 06 00 00	 add	 eax, 1676		; 0000068cH
  003ff	50		 push	 eax
  00400	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00403	81 c1 94 06 00
	00		 add	 ecx, 1684		; 00000694H
  00409	51		 push	 ecx
  0040a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0040d	8b 02		 mov	 eax, DWORD PTR [edx]
  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00412	8b 11		 mov	 edx, DWORD PTR [ecx]
  00414	8b 00		 mov	 eax, DWORD PTR [eax]
  00416	52		 push	 edx
  00417	ff 50 0c	 call	 DWORD PTR [eax+12]
  0041a	3b f4		 cmp	 esi, esp
  0041c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00421	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 86   : 			assert( !FAILED(hr) );

  00424	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00428	7d 1b		 jge	 SHORT $L85086
  0042a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  0042f	83 c0 47	 add	 eax, 71			; 00000047H
  00432	50		 push	 eax
  00433	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  00438	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  0043d	e8 00 00 00 00	 call	 __assert
  00442	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85086:

; 87   : 			hr = m_pJoystick->SetDataFormat(&c_dfDIJoystick);

  00445	8b f4		 mov	 esi, esp
  00447	68 00 00 00 00	 push	 OFFSET FLAT:_c_dfDIJoystick
  0044c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0044f	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  00455	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00458	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  0045e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00460	50		 push	 eax
  00461	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00464	3b f4		 cmp	 esi, esp
  00466	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0046b	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 88   : 			assert( !FAILED(hr) );

  0046e	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00472	7d 1b		 jge	 SHORT $L85087
  00474	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  00479	83 c0 49	 add	 eax, 73			; 00000049H
  0047c	50		 push	 eax
  0047d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  00482	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  00487	e8 00 00 00 00	 call	 __assert
  0048c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85087:

; 89   : 			hr = m_pJoystick->SetCooperativeLevel(hWnd, DISCL_FOREGROUND | DISCL_EXCLUSIVE);

  0048f	8b f4		 mov	 esi, esp
  00491	6a 05		 push	 5
  00493	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00496	50		 push	 eax
  00497	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0049a	8b 91 8c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1676]
  004a0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004a3	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  004a9	8b 12		 mov	 edx, DWORD PTR [edx]
  004ab	51		 push	 ecx
  004ac	ff 52 34	 call	 DWORD PTR [edx+52]
  004af	3b f4		 cmp	 esi, esp
  004b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004b6	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 90   : 			assert( !FAILED(hr) );

  004b9	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  004bd	7d 1b		 jge	 SHORT $L85088
  004bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  004c4	83 c0 4b	 add	 eax, 75			; 0000004bH
  004c7	50		 push	 eax
  004c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  004cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  004d2	e8 00 00 00 00	 call	 __assert
  004d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L85088:

; 91   : 
; 92   : 		// set relative axis mode
; 93   : 			/*DIPROPDWORD dipdw ;
; 94   : 			dipdw.diph.dwSize       = sizeof(DIPROPDWORD) ;
; 95   : 			dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER) ;
; 96   : 			dipdw.diph.dwObj        = 0 ;
; 97   : 			dipdw.diph.dwHow        = DIPH_DEVICE ;
; 98   : 			dipdw.dwData            = DIPROPAXISMODE_REL ;
; 99   : 			if (FAILED(hr = m_pJoystick->SetProperty(DIPROP_AXISMODE, &dipdw.diph)))
; 100  : 				Msg("CUserInput::CUserInput(): FAILED(m_pJoystick->SetProperty(DIPROP_AXISMODE, ...)) == TRUE") ;*/
; 101  : 			
; 102  : 			m_pJoystick->Acquire() ;

  004da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004dd	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  004e3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  004e6	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  004ec	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004ee	8b f4		 mov	 esi, esp
  004f0	50		 push	 eax
  004f1	ff 51 1c	 call	 DWORD PTR [ecx+28]
  004f4	3b f4		 cmp	 esi, esp
  004f6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 103  : 
; 104  : 			hr = m_pJoystick->EnumObjects(EnumAxesCallback, this, DIDFT_AXIS);

  004fb	8b f4		 mov	 esi, esp
  004fd	6a 03		 push	 3
  004ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00502	50		 push	 eax
  00503	68 00 00 00 00	 push	 OFFSET FLAT:?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z ; EnumAxesCallback
  00508	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	8b 91 8c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1676]
  00511	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00514	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  0051a	8b 12		 mov	 edx, DWORD PTR [edx]
  0051c	51		 push	 ecx
  0051d	ff 52 10	 call	 DWORD PTR [edx+16]
  00520	3b f4		 cmp	 esi, esp
  00522	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00527	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 105  : 			assert( !FAILED(hr) );

  0052a	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0052e	7d 1b		 jge	 SHORT $L84741
  00530	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1???0CUserInput@@QAE@PAUHWND__@@_NM11@Z@4JA
  00535	83 c0 5a	 add	 eax, 90			; 0000005aH
  00538	50		 push	 eax
  00539	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EM@GMPNAJJC@c?3?2documents?5and?5settings?2dom?2my@
  0053e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NKNCPJJD@?$CBFAILED?$CIhr?$CJ?$AA@
  00543	e8 00 00 00 00	 call	 __assert
  00548	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84741:

; 106  : 		}
; 107  : 	}

  0054b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0054e	5f		 pop	 edi
  0054f	5e		 pop	 esi
  00550	5b		 pop	 ebx
  00551	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00557	3b ec		 cmp	 ebp, esp
  00559	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0055e	8b e5		 mov	 esp, ebp
  00560	5d		 pop	 ebp
  00561	c2 14 00	 ret	 20			; 00000014H
??0CUserInput@@QAE@PAUHWND__@@_NM11@Z ENDP		; CUserInput::CUserInput
; Function compile flags: /Odt /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EPAX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$L84787:
  0001e	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00021	83 e8 01	 sub	 eax, 1
  00024	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00027	83 7d 10 00	 cmp	 DWORD PTR ___n$[ebp], 0
  0002b	7c 1a		 jl	 SHORT $L84785
  0002d	8b f4		 mov	 esi, esp
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00032	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0003f	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00042	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00045	eb d7		 jmp	 SHORT $L84787
$L84785:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1CUserInput@@QAE@XZ				; CUserInput::~CUserInput
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ??1CUserInput@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
??1CUserInput@@QAE@XZ PROC NEAR				; CUserInput::~CUserInput, COMDAT
; _this$ = ecx

; 109  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 110  : 		if (m_pKeyboard)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002a	74 40		 je	 SHORT $L84793

; 111  : 		{
; 112  : 			m_pKeyboard->Unacquire() ;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003a	8b f4		 mov	 esi, esp
  0003c	50		 push	 eax
  0003d	ff 51 20	 call	 DWORD PTR [ecx+32]
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 113  : 			m_pKeyboard->Release() ;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00050	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	8b f4		 mov	 esi, esp
  00057	50		 push	 eax
  00058	ff 51 08	 call	 DWORD PTR [ecx+8]
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 114  : 			m_pKeyboard = NULL ;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L84793:

; 115  : 		}
; 116  : 
; 117  : 		if (m_pJoystick) 

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 b8 8c 06 00
	00 00		 cmp	 DWORD PTR [eax+1676], 0
  00076	74 4f		 je	 SHORT $L84794

; 118  : 		{
; 119  : 			m_pJoystick->Unacquire() ;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  00081	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  0008a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0008c	8b f4		 mov	 esi, esp
  0008e	50		 push	 eax
  0008f	ff 51 20	 call	 DWORD PTR [ecx+32]
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 120  : 			m_pJoystick->Release() ;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  000ab	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ad	8b f4		 mov	 esi, esp
  000af	50		 push	 eax
  000b0	ff 51 08	 call	 DWORD PTR [ecx+8]
  000b3	3b f4		 cmp	 esi, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 121  : 			m_pJoystick = NULL ;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c7 80 8c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1676], 0
$L84794:

; 122  : 		}
; 123  :     
; 124  : 		if (m_pMouse) 

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	83 b8 40 06 00
	00 00		 cmp	 DWORD PTR [eax+1600], 0
  000d1	74 4f		 je	 SHORT $L84795

; 125  : 		{
; 126  : 			m_pMouse->Unacquire() ;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000df	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  000e5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e7	8b f4		 mov	 esi, esp
  000e9	50		 push	 eax
  000ea	ff 51 20	 call	 DWORD PTR [ecx+32]
  000ed	3b f4		 cmp	 esi, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 127  : 			m_pMouse->Release() ;

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00106	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00108	8b f4		 mov	 esi, esp
  0010a	50		 push	 eax
  0010b	ff 51 08	 call	 DWORD PTR [ecx+8]
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 128  : 			m_pMouse = NULL ;

  00115	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00118	c7 80 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1600], 0
$L84795:

; 129  : 		}
; 130  : 
; 131  : 		if (m_pDI)

  00122	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00125	83 38 00	 cmp	 DWORD PTR [eax], 0
  00128	74 22		 je	 SHORT $L84792

; 132  : 		{
; 133  : 			m_pDI->Release() ;

  0012a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00132	8b 02		 mov	 eax, DWORD PTR [edx]
  00134	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00136	8b f4		 mov	 esi, esp
  00138	50		 push	 eax
  00139	ff 51 08	 call	 DWORD PTR [ecx+8]
  0013c	3b f4		 cmp	 esi, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 134  : 			m_pDI = NULL ;

  00143	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00146	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L84792:

; 135  : 		}
; 136  : 	}

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00155	3b ec		 cmp	 ebp, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
??1CUserInput@@QAE@XZ ENDP				; CUserInput::~CUserInput
_TEXT	ENDS
PUBLIC	?Init@CUserInput@@QAEHXZ			; CUserInput::Init
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?Init@CUserInput@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8
?Init@CUserInput@@QAEHXZ PROC NEAR			; CUserInput::Init, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 		m_fMouseStickyX = m_fMouseStickyY = m_fMouseStickyZ = 0 ;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 80 7c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1660], 0
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 81 78 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1656], 0
  0003d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00040	c7 82 74 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1652], 0

; 141  : 	}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?Init@CUserInput@@QAEHXZ ENDP				; CUserInput::Init
_TEXT	ENDS
EXTRN	_strcpy:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z
_TEXT	SEGMENT
_lpddi$ = 8
_pvRef$ = 12
?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z PROC NEAR ; EnumJoysticksCallback, COMDAT

; 151  : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 152  : 		if (GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_JOYSTICK)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  00021	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00024	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002a	0f b6 d1	 movzx	 edx, cl
  0002d	83 fa 14	 cmp	 edx, 20			; 00000014H
  00030	75 6a		 jne	 SHORT $L84806

; 153  : 		{
; 154  : 			((CUserInput*)pvRef)->m_bJoystickPresent = TRUE ;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _pvRef$[ebp]
  00035	c7 80 90 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1680], 1

; 155  : 			((CUserInput*)pvRef)->m_guidJoystick = lpddi->guidInstance ;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  00042	83 c0 04	 add	 eax, 4
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00048	81 c1 94 06 00
	00		 add	 ecx, 1684		; 00000694H
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	89 11		 mov	 DWORD PTR [ecx], edx
  00052	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00055	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00058	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0005e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00061	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 156  : 			strcpy(((CUserInput*)pvRef)->m_szJoystickInstanceName, lpddi->tszInstanceName) ;

  00064	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  00067	83 c0 28	 add	 eax, 40			; 00000028H
  0006a	50		 push	 eax
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  0006e	81 c1 a4 06 00
	00		 add	 ecx, 1700		; 000006a4H
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _strcpy
  0007a	83 c4 08	 add	 esp, 8

; 157  : 			strcpy(((CUserInput*)pvRef)->m_szJoystickProductName, lpddi->tszProductName) ;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  00080	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00085	50		 push	 eax
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00089	81 c1 a8 07 00
	00		 add	 ecx, 1960		; 000007a8H
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _strcpy
  00095	83 c4 08	 add	 esp, 8

; 158  : 			return DIENUM_STOP ;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 05		 jmp	 SHORT $L84803
$L84806:

; 159  : 		}
; 160  : 		return DIENUM_CONTINUE ;

  0009c	b8 01 00 00 00	 mov	 eax, 1
$L84803:

; 161  : 	}

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000aa	3b ec		 cmp	 ebp, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
?EnumJoysticksCallback@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z ENDP ; EnumJoysticksCallback
_TEXT	ENDS
PUBLIC	_==
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	_GUID_XAxis:BYTE
EXTRN	_GUID_YAxis:BYTE
EXTRN	_GUID_ZAxis:BYTE
EXTRN	_GUID_RxAxis:BYTE
EXTRN	_GUID_RyAxis:BYTE
EXTRN	_GUID_RzAxis:BYTE
EXTRN	_GUID_Slider:BYTE
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z
_TEXT	SEGMENT
_diprg$ = -40
_pUI$ = -8
_pdidoi$ = 8
_pContext$ = 12
?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z PROC NEAR ; EnumAxesCallback, COMDAT

; 171  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 172  : 		CUserInput* pUI = (CUserInput*)pContext ;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pContext$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pUI$[ebp], eax

; 173  : 
; 174  : 		DIPROPRANGE diprg; 
; 175  : 		diprg.diph.dwSize       = sizeof(DIPROPRANGE); 

  00024	c7 45 d8 18 00
	00 00		 mov	 DWORD PTR _diprg$[ebp], 24 ; 00000018H

; 176  : 		diprg.diph.dwHeaderSize = sizeof(DIPROPHEADER); 

  0002b	c7 45 dc 10 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+4], 16 ; 00000010H

; 177  : 		diprg.diph.dwHow        = DIPH_BYID; 

  00032	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+12], 2

; 178  : 		diprg.diph.dwObj        = pdidoi->dwType; // specify the enumerated axis

  00039	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  0003c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003f	89 4d e0	 mov	 DWORD PTR _diprg$[ebp+8], ecx

; 179  : 		diprg.lMin              = -1000; 

  00042	c7 45 e8 18 fc
	ff ff		 mov	 DWORD PTR _diprg$[ebp+16], -1000 ; fffffc18H

; 180  : 		diprg.lMax              = +1000; 

  00049	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _diprg$[ebp+20], 1000 ; 000003e8H

; 181  :     
; 182  : 	// figure out which axes the joystick supports
; 183  : 		if (pdidoi->guidType == GUID_XAxis)

  00050	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_XAxis
  00055	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  00058	83 c0 04	 add	 eax, 4
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _==
  00061	83 c4 08	 add	 esp, 8

; 184  : 		{
; 185  : 		// present on SideWinder Precision 2
; 186  : 		}
; 187  : 		if (pdidoi->guidType == GUID_YAxis)

  00064	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_YAxis
  00069	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  0006c	83 c0 04	 add	 eax, 4
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _==
  00075	83 c4 08	 add	 esp, 8

; 188  : 		{
; 189  : 		// present on SideWinder Precision 2
; 190  : 		}
; 191  : 		if (pdidoi->guidType == GUID_ZAxis)

  00078	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_ZAxis
  0007d	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  00080	83 c0 04	 add	 eax, 4
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _==
  00089	83 c4 08	 add	 esp, 8

; 192  : 		{
; 193  : 		}
; 194  : 
; 195  : 		if (pdidoi->guidType == GUID_RxAxis)

  0008c	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_RxAxis
  00091	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  00094	83 c0 04	 add	 eax, 4
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _==
  0009d	83 c4 08	 add	 esp, 8

; 196  : 		{
; 197  : 		}
; 198  : 		if (pdidoi->guidType == GUID_RyAxis)

  000a0	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_RyAxis
  000a5	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  000a8	83 c0 04	 add	 eax, 4
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _==
  000b1	83 c4 08	 add	 esp, 8

; 199  : 		{
; 200  : 		}
; 201  : 		if (pdidoi->guidType == GUID_RzAxis)

  000b4	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_RzAxis
  000b9	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  000bc	83 c0 04	 add	 eax, 4
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _==
  000c5	83 c4 08	 add	 esp, 8

; 202  : 		{
; 203  : 		// present on SideWinder Precision 2
; 204  : 		}
; 205  : 
; 206  : 		if (pdidoi->guidType == GUID_Slider)

  000c8	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Slider
  000cd	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  000d0	83 c0 04	 add	 eax, 4
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _==
  000d9	83 c4 08	 add	 esp, 8
  000dc	85 c0		 test	 eax, eax
  000de	74 0e		 je	 SHORT $L84826

; 207  : 		{
; 208  : 		// present on SideWinder Precision 2
; 209  : 			diprg.lMin = +0; 

  000e0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+16], 0

; 210  : 			diprg.lMax = +1000; 

  000e7	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _diprg$[ebp+20], 1000 ; 000003e8H
$L84826:

; 211  : 		}
; 212  : 
; 213  : 	// set the range for the axis
; 214  : 		if( FAILED( pUI->m_pJoystick->SetProperty( DIPROP_RANGE, &diprg.diph ) ) )

  000ee	8b f4		 mov	 esi, esp
  000f0	8d 45 d8	 lea	 eax, DWORD PTR _diprg$[ebp]
  000f3	50		 push	 eax
  000f4	6a 04		 push	 4
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _pUI$[ebp]
  000f9	8b 91 8c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1676]
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _pUI$[ebp]
  00102	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  00108	8b 12		 mov	 edx, DWORD PTR [edx]
  0010a	51		 push	 ecx
  0010b	ff 52 18	 call	 DWORD PTR [edx+24]
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	85 c0		 test	 eax, eax
  00117	7d 04		 jge	 SHORT $L84829

; 215  : 			return DIENUM_STOP;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 05		 jmp	 SHORT $L84814
$L84829:

; 216  : 
; 217  : 		return DIENUM_CONTINUE;

  0011d	b8 01 00 00 00	 mov	 eax, 1
$L84814:

; 218  : 	}

  00122	52		 push	 edx
  00123	8b cd		 mov	 ecx, ebp
  00125	50		 push	 eax
  00126	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85112
  0012c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00131	58		 pop	 eax
  00132	5a		 pop	 edx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0013c	3b ec		 cmp	 ebp, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 08 00	 ret	 8
$L85112:
  00149	01 00 00 00	 DD	 1
  0014d	00 00 00 00	 DD	 $L85111
$L85111:
  00151	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00155	18 00 00 00	 DD	 24			; 00000018H
  00159	00 00 00 00	 DD	 $L85110
$L85110:
  0015d	64		 DB	 100			; 00000064H
  0015e	69		 DB	 105			; 00000069H
  0015f	70		 DB	 112			; 00000070H
  00160	72		 DB	 114			; 00000072H
  00161	67		 DB	 103			; 00000067H
  00162	00		 DB	 0
?EnumAxesCallback@@YGHPBUDIDEVICEOBJECTINSTANCEA@@PAX@Z ENDP ; EnumAxesCallback
_TEXT	ENDS
PUBLIC	_IsEqualGUID
; Function compile flags: /Odt /RTCsu /ZI
; File c:\program files\microsoft visual studio .net\vc7\platformsdk\include\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==	PROC NEAR					; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 194  :     return IsEqualGUID(guidOne,guidOther);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _IsEqualGUID
  0002b	83 c4 08	 add	 esp, 8

; 195  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID PROC NEAR					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0001e	6a 10		 push	 16			; 00000010H
  00020	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memcmp
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	f7 d8		 neg	 eax
  00032	1b c0		 sbb	 eax, eax
  00034	40		 inc	 eax

; 162  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	?Poll@CUserInput@@QAEJ_N@Z			; CUserInput::Poll
PUBLIC	?PollKeyboard@CUserInput@@QAEJ_N@Z		; CUserInput::PollKeyboard
PUBLIC	?PollMouseSticky@CUserInput@@QAEJ_N@Z		; CUserInput::PollMouseSticky
PUBLIC	?PollJoystick@CUserInput@@QAEJ_N@Z		; CUserInput::PollJoystick
; Function compile flags: /Odt /RTCsu /ZI
; File c:\documents and settings\dom\my documents\_dev\ae\xlr8a\x7g\cuserinput.cpp
;	COMDAT ?Poll@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT
_this$ = -8
_bInGame$ = 8
?Poll@CUserInput@@QAEJ_N@Z PROC NEAR			; CUserInput::Poll, COMDAT
; _this$ = ecx

; 226  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 227  : 	// default mapped values
; 228  : 		m_FlightControls.fSteerLeft = 0 ;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 80 b4 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2228], 0

; 229  : 		m_FlightControls.fSteerRight = 0 ;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 80 b8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2232], 0

; 230  : 		m_FlightControls.fStrafeLeft = 0 ;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 80 cc 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2252], 0

; 231  : 		m_FlightControls.fStrafeRight = 0 ;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 80 d0 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2256], 0

; 232  : 		m_FlightControls.fAccelerate = 0 ;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 80 ac 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2220], 0

; 233  : 		m_FlightControls.fBrake = 0 ;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 80 b0 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2224], 0

; 234  : 		m_FlightControls.fDive = 0 ;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 80 bc 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2236], 0

; 235  : 		m_FlightControls.fClimb = 0 ;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	c7 80 c0 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2240], 0

; 236  : 		m_FlightControls.fRollLeft = 0 ;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	c7 80 c4 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2244], 0

; 237  : 		m_FlightControls.fRollRight = 0 ;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c7 80 c8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2248], 0

; 238  : 		m_FlightControls.bFireA = FALSE ;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	c7 80 e0 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2272], 0

; 239  : 		m_FlightControls.bFireB = FALSE ;

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	c7 80 e4 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2276], 0

; 240  : 		m_FlightControls.bNextWeapon = FALSE ;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	c7 80 d8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2264], 0

; 241  : 		m_FlightControls.bPrevWeapon = FALSE ;

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	c7 80 dc 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2268], 0

; 242  : 		m_FlightControls.bSteerAndRoll = FALSE ;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	c7 80 d4 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2260], 0

; 243  : 
; 244  : 	// poll
; 245  : 		PollKeyboard( bInGame );

  000e6	8a 45 08	 mov	 al, BYTE PTR _bInGame$[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	e8 00 00 00 00	 call	 ?PollKeyboard@CUserInput@@QAEJ_N@Z ; CUserInput::PollKeyboard

; 246  : 
; 247  : 		/*if( m_bNonStickyMouse )		NON_STICKY MOUSE POLLING SUCKS BIG TIME, SHOULD FIX IT OR DISABLE IT
; 248  : 			PollMouse( bInGame );
; 249  : 		else*/
; 250  : 			PollMouseSticky( bInGame );

  000f2	8a 45 08	 mov	 al, BYTE PTR _bInGame$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?PollMouseSticky@CUserInput@@QAEJ_N@Z ; CUserInput::PollMouseSticky

; 251  : 
; 252  : 		PollJoystick( bInGame );

  000fe	8a 45 08	 mov	 al, BYTE PTR _bInGame$[ebp]
  00101	50		 push	 eax
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?PollJoystick@CUserInput@@QAEJ_N@Z ; CUserInput::PollJoystick

; 253  : 
; 254  : 		return S_OK ;

  0010a	33 c0		 xor	 eax, eax

; 255  : 	}

  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 04 00	 ret	 4
?Poll@CUserInput@@QAEJ_N@Z ENDP				; CUserInput::Poll
_TEXT	ENDS
PUBLIC	__real@447a0000
PUBLIC	__real@41a00000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f800000
PUBLIC	_fabsf
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_memset:NEAR
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?PollJoystick@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT
_dijs$ = -112
_hr$ = -24
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_bInGame$ = 8
?PollJoystick@CUserInput@@QAEJ_N@Z PROC NEAR		; CUserInput::PollJoystick, COMDAT
; _this$ = ecx

; 263  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00013	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 264  : 		HRESULT	   hr ;
; 265  : 		DIJOYSTATE dijs ;
; 266  : 
; 267  : 		if (!m_pJoystick)

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 b8 8c 06 00
	00 00		 cmp	 DWORD PTR [eax+1676], 0
  00038	75 0a		 jne	 SHORT $L84841

; 268  : 			return E_FAIL ;

  0003a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0003f	e9 73 02 00 00	 jmp	 $L84838
$L84841:

; 269  : 
; 270  : 		ZeroMemory(&dijs, sizeof(dijs)) ;

  00044	6a 50		 push	 80			; 00000050H
  00046	6a 00		 push	 0
  00048	8d 45 90	 lea	 eax, DWORD PTR _dijs$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _memset
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 271  : 		hr = m_pJoystick->GetDeviceState(sizeof(dijs), &dijs) ;

  00054	8b f4		 mov	 esi, esp
  00056	8d 45 90	 lea	 eax, DWORD PTR _dijs$[ebp]
  00059	50		 push	 eax
  0005a	6a 50		 push	 80			; 00000050H
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8b 91 8c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1676]
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  0006e	8b 12		 mov	 edx, DWORD PTR [edx]
  00070	51		 push	 ecx
  00071	ff 52 24	 call	 DWORD PTR [edx+36]
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax

; 272  : 		if (FAILED(hr)) 

  0007e	83 7d e8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00082	7d 5d		 jge	 SHORT $L84844

; 273  : 		{
; 274  : 			hr = m_pJoystick->Acquire() ;

  00084	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00090	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  00096	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00098	8b f4		 mov	 esi, esp
  0009a	50		 push	 eax
  0009b	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
$L84846:

; 275  : 			while (hr == DIERR_INPUTLOST) 

  000a8	81 7d e8 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  000af	75 26		 jne	 SHORT $L84847

; 276  : 				hr = m_pJoystick->Acquire() ;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 88 8c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1676]
  000ba	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	8b 82 8c 06 00
	00		 mov	 eax, DWORD PTR [edx+1676]
  000c3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c5	8b f4		 mov	 esi, esp
  000c7	50		 push	 eax
  000c8	ff 51 1c	 call	 DWORD PTR [ecx+28]
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	89 45 e8	 mov	 DWORD PTR _hr$[ebp], eax
  000d5	eb d1		 jmp	 SHORT $L84846
$L84847:

; 277  : 
; 278  : 			return E_FAIL ;

  000d7	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000dc	e9 d6 01 00 00	 jmp	 $L84838
$L84844:

; 279  : 		}
; 280  : 
; 281  : 	//
; 282  : 	// Map flight controls:
; 283  : 	//
; 284  : 	// Notice that we asign a *fraction* of MAX_FLIGHTMAP, here. This is
; 285  : 	// because the joystick can report this fraction of MAX_FLIGHTMAP *per frame*,
; 286  : 	// with *no movement* from the user. Contrast with the mouse, which the user has to 
; 287  : 	// physically move, per frame, in order to report MAX_FLIGHTMAP... this is in order
; 288  : 	// to balance the two input devices.
; 289  : 	//
; 290  : 		if( dijs.lX < -2 )

  000e1	83 7d 90 fe	 cmp	 DWORD PTR _dijs$[ebp], -2 ; fffffffeH
  000e5	7d 33		 jge	 SHORT $L84853

; 291  : 			m_FlightControls.fSteerLeft += fabsf((float)dijs.lX) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  000e7	db 45 90	 fild	 DWORD PTR _dijs$[ebp]
  000ea	51		 push	 ecx
  000eb	d9 1c 24	 fstp	 DWORD PTR [esp]
  000ee	e8 00 00 00 00	 call	 _fabsf
  000f3	83 c4 04	 add	 esp, 4
  000f6	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  000fc	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  00102	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  00108	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	d8 80 b4 08 00
	00		 fadd	 DWORD PTR [eax+2228]
  00111	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	d9 99 b4 08 00
	00		 fstp	 DWORD PTR [ecx+2228]
$L84853:

; 292  : 		if( dijs.lX > +2 )

  0011a	83 7d 90 02	 cmp	 DWORD PTR _dijs$[ebp], 2
  0011e	7e 33		 jle	 SHORT $L84855

; 293  : 			m_FlightControls.fSteerRight += fabsf((float)dijs.lX) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  00120	db 45 90	 fild	 DWORD PTR _dijs$[ebp]
  00123	51		 push	 ecx
  00124	d9 1c 24	 fstp	 DWORD PTR [esp]
  00127	e8 00 00 00 00	 call	 _fabsf
  0012c	83 c4 04	 add	 esp, 4
  0012f	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  00135	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  0013b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  00141	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00144	d8 80 b8 08 00
	00		 fadd	 DWORD PTR [eax+2232]
  0014a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	d9 99 b8 08 00
	00		 fstp	 DWORD PTR [ecx+2232]
$L84855:

; 294  : 
; 295  : 		if( dijs.lY < -2 )

  00153	83 7d 94 fe	 cmp	 DWORD PTR _dijs$[ebp+4], -2 ; fffffffeH
  00157	7d 33		 jge	 SHORT $L84857

; 296  : 			m_FlightControls.fDive += fabsf((float)dijs.lY) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  00159	db 45 94	 fild	 DWORD PTR _dijs$[ebp+4]
  0015c	51		 push	 ecx
  0015d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00160	e8 00 00 00 00	 call	 _fabsf
  00165	83 c4 04	 add	 esp, 4
  00168	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  0016e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  00174	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  0017a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	d8 80 bc 08 00
	00		 fadd	 DWORD PTR [eax+2236]
  00183	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00186	d9 99 bc 08 00
	00		 fstp	 DWORD PTR [ecx+2236]
$L84857:

; 297  : 		if( dijs.lY > +2 )

  0018c	83 7d 94 02	 cmp	 DWORD PTR _dijs$[ebp+4], 2
  00190	7e 33		 jle	 SHORT $L84859

; 298  : 			m_FlightControls.fClimb += fabsf((float)dijs.lY) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  00192	db 45 94	 fild	 DWORD PTR _dijs$[ebp+4]
  00195	51		 push	 ecx
  00196	d9 1c 24	 fstp	 DWORD PTR [esp]
  00199	e8 00 00 00 00	 call	 _fabsf
  0019e	83 c4 04	 add	 esp, 4
  001a1	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  001a7	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  001ad	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  001b3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	d8 80 c0 08 00
	00		 fadd	 DWORD PTR [eax+2240]
  001bc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	d9 99 c0 08 00
	00		 fstp	 DWORD PTR [ecx+2240]
$L84859:

; 299  : 
; 300  : 		if( dijs.lRz < -2 )

  001c5	83 7d a4 fe	 cmp	 DWORD PTR _dijs$[ebp+20], -2 ; fffffffeH
  001c9	7d 33		 jge	 SHORT $L84861

; 301  : 			m_FlightControls.fRollLeft += fabsf((float)dijs.lRz) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  001cb	db 45 a4	 fild	 DWORD PTR _dijs$[ebp+20]
  001ce	51		 push	 ecx
  001cf	d9 1c 24	 fstp	 DWORD PTR [esp]
  001d2	e8 00 00 00 00	 call	 _fabsf
  001d7	83 c4 04	 add	 esp, 4
  001da	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  001e0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  001e6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  001ec	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	d8 80 c4 08 00
	00		 fadd	 DWORD PTR [eax+2244]
  001f5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	d9 99 c4 08 00
	00		 fstp	 DWORD PTR [ecx+2244]
$L84861:

; 302  : 		if( dijs.lRz > +2 )

  001fe	83 7d a4 02	 cmp	 DWORD PTR _dijs$[ebp+20], 2
  00202	7e 33		 jle	 SHORT $L84863

; 303  : 			m_FlightControls.fRollRight += fabsf((float)dijs.lRz) / 1000.0f * MAX_FLIGHTMAP * 0.6f ;

  00204	db 45 a4	 fild	 DWORD PTR _dijs$[ebp+20]
  00207	51		 push	 ecx
  00208	d9 1c 24	 fstp	 DWORD PTR [esp]
  0020b	e8 00 00 00 00	 call	 _fabsf
  00210	83 c4 04	 add	 esp, 4
  00213	d8 35 00 00 00
	00		 fdiv	 DWORD PTR __real@447a0000
  00219	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41a00000
  0021f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f19999a
  00225	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00228	d8 80 c8 08 00
	00		 fadd	 DWORD PTR [eax+2248]
  0022e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	d9 99 c8 08 00
	00		 fstp	 DWORD PTR [ecx+2248]
$L84863:

; 304  : 
; 305  : 		if (dijs.rgbButtons[0] & 0x80)

  00237	0f b6 45 c0	 movzx	 eax, BYTE PTR _dijs$[ebp+48]
  0023b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00240	85 c0		 test	 eax, eax
  00242	74 0d		 je	 SHORT $L84865

; 306  : 			m_FlightControls.bFireA = TRUE ;

  00244	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00247	c7 80 e0 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2272], 1
$L84865:

; 307  : 		if (dijs.rgbButtons[1] & 0x80)

  00251	0f b6 45 c1	 movzx	 eax, BYTE PTR _dijs$[ebp+49]
  00255	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0025a	85 c0		 test	 eax, eax
  0025c	74 0d		 je	 SHORT $L84866

; 308  : 			//m_FlightControls.bFireB = TRUE ;
; 309  : 			m_FlightControls.bNextWeapon = TRUE ;

  0025e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00261	c7 80 d8 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2264], 1
$L84866:

; 310  : 
; 311  : 		if (dijs.rgbButtons[2] & 0x80)

  0026b	0f b6 45 c2	 movzx	 eax, BYTE PTR _dijs$[ebp+50]
  0026f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00274	85 c0		 test	 eax, eax
  00276	74 18		 je	 SHORT $L84867

; 312  : 			m_FlightControls.fAccelerate += 1.0f ;

  00278	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0027b	d9 80 ac 08 00
	00		 fld	 DWORD PTR [eax+2220]
  00281	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00287	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	d9 99 ac 08 00
	00		 fstp	 DWORD PTR [ecx+2220]
$L84867:

; 313  : 		if (dijs.rgbButtons[3] & 0x80)

  00290	0f b6 45 c3	 movzx	 eax, BYTE PTR _dijs$[ebp+51]
  00294	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00299	85 c0		 test	 eax, eax
  0029b	74 18		 je	 SHORT $L84868

; 314  : 			m_FlightControls.fBrake += 1.0f ;

  0029d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	d9 80 b0 08 00
	00		 fld	 DWORD PTR [eax+2224]
  002a6	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  002ac	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002af	d9 99 b0 08 00
	00		 fstp	 DWORD PTR [ecx+2224]
$L84868:

; 315  : 
; 316  : 		//if( dijs.lRz != 0 )
; 317  : 		//	ods("[%d %d %d %d]\n", (int)dijs.lX, (int)dijs.lY, (int)dijs.lRz, (int)dijs.rglSlider[0]) ;
; 318  : 
; 319  : 		return S_OK ;

  002b5	33 c0		 xor	 eax, eax
$L84838:

; 320  : 	}

  002b7	52		 push	 edx
  002b8	8b cd		 mov	 ecx, ebp
  002ba	50		 push	 eax
  002bb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85135
  002c1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002c6	58		 pop	 eax
  002c7	5a		 pop	 edx
  002c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cb	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  002ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx
  002d6	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  002dc	3b ec		 cmp	 ebp, esp
  002de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c2 04 00	 ret	 4
$L85135:
  002e9	01 00 00 00	 DD	 1
  002ed	00 00 00 00	 DD	 $L85134
$L85134:
  002f1	90 ff ff ff	 DD	 -112			; ffffff90H
  002f5	50 00 00 00	 DD	 80			; 00000050H
  002f9	00 00 00 00	 DD	 $L85131
$L85131:
  002fd	64		 DB	 100			; 00000064H
  002fe	69		 DB	 105			; 00000069H
  002ff	6a		 DB	 106			; 0000006aH
  00300	73		 DB	 115			; 00000073H
  00301	00		 DB	 0
?PollJoystick@CUserInput@@QAEJ_N@Z ENDP			; CUserInput::PollJoystick
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?PollKeyboard@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT
_i$84916 = -44
_i$84910 = -32
_hr$ = -20
_this$ = -8
_bInGame$ = 8
?PollKeyboard@CUserInput@@QAEJ_N@Z PROC NEAR		; CUserInput::PollKeyboard, COMDAT
; _this$ = ecx

; 328  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 329  : 		HRESULT hr ;
; 330  : 
; 331  : 	    m_bF1 = m_bF2 = m_bF3 = m_bF4 = m_bF5 = m_bF6 = m_bF7 = m_bF8 = m_bF9 = m_bF10 = m_bF11 = m_bF12 = FALSE ;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 80 38 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1592], 0
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 81 34 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1588], 0
  0003d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00040	c7 82 30 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1584], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 80 2c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1580], 0
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	c7 81 28 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1576], 0
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	c7 82 24 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1572], 0
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 80 20 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1568], 0
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	c7 81 1c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1564], 0
  0008b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	c7 82 18 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1560], 0
  00098	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c7 80 14 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1556], 0
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	c7 81 10 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1552], 0
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	c7 82 0c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1548], 0

; 332  : 		m_bAnyKey = FALSE ;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	c7 80 3c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1596], 0

; 333  : 
; 334  : 	//
; 335  : 	// Get raw data:
; 336  : 	// 
; 337  : 		if (!m_pKeyboard) 

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000d3	75 0a		 jne	 SHORT $L84875

; 338  : 			return E_FAIL ;

  000d5	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000da	e9 8b 04 00 00	 jmp	 $L84873
$L84875:

; 339  : 
; 340  : 		ZeroMemory(&m_bKB_Cur, sizeof(m_bKB_Cur)) ;

  000df	68 00 01 00 00	 push	 256			; 00000100H
  000e4	6a 00		 push	 0
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	05 08 01 00 00	 add	 eax, 264		; 00000108H
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _memset
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 341  : 		hr = m_pKeyboard->GetDeviceState(sizeof(m_bKB_Cur), &m_bKB_Cur) ;

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	05 08 01 00 00	 add	 eax, 264		; 00000108H
  000ff	8b f4		 mov	 esi, esp
  00101	50		 push	 eax
  00102	68 00 01 00 00	 push	 256			; 00000100H
  00107	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	8b 12		 mov	 edx, DWORD PTR [edx]
  00115	51		 push	 ecx
  00116	ff 52 24	 call	 DWORD PTR [edx+36]
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 342  : 		if (FAILED(hr)) 

  00123	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00127	7d 51		 jge	 SHORT $L84878

; 343  : 		{
; 344  : 			hr = m_pKeyboard->Acquire();

  00129	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00132	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00135	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00137	8b f4		 mov	 esi, esp
  00139	50		 push	 eax
  0013a	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0013d	3b f4		 cmp	 esi, esp
  0013f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00144	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax
$L84880:

; 345  : 			while (hr == DIERR_INPUTLOST) 

  00147	81 7d ec 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  0014e	75 20		 jne	 SHORT $L84881

; 346  : 				hr = m_pKeyboard->Acquire() ;

  00150	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00153	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00156	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00159	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0015c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0015e	8b f4		 mov	 esi, esp
  00160	50		 push	 eax
  00161	ff 51 1c	 call	 DWORD PTR [ecx+28]
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax
  0016e	eb d7		 jmp	 SHORT $L84880
$L84881:

; 347  : 
; 348  : 			return E_FAIL ;

  00170	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00175	e9 f0 03 00 00	 jmp	 $L84873
$L84878:

; 349  : 		}
; 350  : 
; 351  : 	//
; 352  : 	// Map flight controls:
; 353  : 	//
; 354  : 		// this is no good, steering shouldn't be done by KB:
; 355  : 		/*if (m_bKB_Cur[DIK_LEFT] & 0x80 || m_bKB_Cur[DIK_NUMPAD4] & 0x80)
; 356  : 			m_FlightControls.fSteerLeft += 1.0f ;
; 357  : 		if (m_bKB_Cur[DIK_RIGHT] & 0x80 || m_bKB_Cur[DIK_NUMPAD6] & 0x80)
; 358  : 			m_FlightControls.fSteerRight += 1.0f ;*/
; 359  : 
; 360  : 		if (m_bKB_Cur[DIK_NUMPAD1] & 0x80 || m_bKB_Cur[DIK_CAPITAL] & 0x80)

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	0f b6 88 57 01
	00 00		 movzx	 ecx, BYTE PTR [eax+343]
  00184	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0018a	85 c9		 test	 ecx, ecx
  0018c	75 14		 jne	 SHORT $L84888
  0018e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00191	0f b6 88 42 01
	00 00		 movzx	 ecx, BYTE PTR [eax+322]
  00198	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0019e	85 c9		 test	 ecx, ecx
  001a0	74 18		 je	 SHORT $L84887
$L84888:

; 361  : 			m_FlightControls.fStrafeLeft += 1.0f ;

  001a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	d9 80 cc 08 00
	00		 fld	 DWORD PTR [eax+2252]
  001ab	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  001b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	d9 99 cc 08 00
	00		 fstp	 DWORD PTR [ecx+2252]
$L84887:

; 362  : 		if (m_bKB_Cur[DIK_NUMPAD3] & 0x80 || m_bKB_Cur[DIK_S] & 0x80)

  001ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001bd	0f b6 88 59 01
	00 00		 movzx	 ecx, BYTE PTR [eax+345]
  001c4	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  001ca	85 c9		 test	 ecx, ecx
  001cc	75 14		 jne	 SHORT $L84890
  001ce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	0f b6 88 27 01
	00 00		 movzx	 ecx, BYTE PTR [eax+295]
  001d8	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  001de	85 c9		 test	 ecx, ecx
  001e0	74 18		 je	 SHORT $L84889
$L84890:

; 363  : 			m_FlightControls.fStrafeRight += 1.0f ;

  001e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	d9 80 d0 08 00
	00		 fld	 DWORD PTR [eax+2256]
  001eb	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  001f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	d9 99 d0 08 00
	00		 fstp	 DWORD PTR [ecx+2256]
$L84889:

; 364  : 
; 365  : 		if( m_bKB_Cur[ DIK_UP ] & 0x80 || m_bKB_Cur[ DIK_NUMPAD8 ] & 0x80 || m_bKB_Cur[ DIK_Q ] & 0x80 )

  001fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001fd	0f b6 88 d0 01
	00 00		 movzx	 ecx, BYTE PTR [eax+464]
  00204	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0020a	85 c9		 test	 ecx, ecx
  0020c	75 28		 jne	 SHORT $L84892
  0020e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00211	0f b6 88 50 01
	00 00		 movzx	 ecx, BYTE PTR [eax+336]
  00218	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0021e	85 c9		 test	 ecx, ecx
  00220	75 14		 jne	 SHORT $L84892
  00222	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00225	0f b6 88 18 01
	00 00		 movzx	 ecx, BYTE PTR [eax+280]
  0022c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00232	85 c9		 test	 ecx, ecx
  00234	74 18		 je	 SHORT $L84891
$L84892:

; 366  : 			m_FlightControls.fAccelerate += 1.0f ;

  00236	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00239	d9 80 ac 08 00
	00		 fld	 DWORD PTR [eax+2220]
  0023f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00245	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00248	d9 99 ac 08 00
	00		 fstp	 DWORD PTR [ecx+2220]
$L84891:

; 367  : 		if( m_bKB_Cur[ DIK_DOWN ] & 0x80 || m_bKB_Cur[ DIK_NUMPAD2 ] & 0x80 || m_bKB_Cur[ DIK_A ] & 0x80 )

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00251	0f b6 88 d8 01
	00 00		 movzx	 ecx, BYTE PTR [eax+472]
  00258	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0025e	85 c9		 test	 ecx, ecx
  00260	75 28		 jne	 SHORT $L84894
  00262	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00265	0f b6 88 58 01
	00 00		 movzx	 ecx, BYTE PTR [eax+344]
  0026c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00272	85 c9		 test	 ecx, ecx
  00274	75 14		 jne	 SHORT $L84894
  00276	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00279	0f b6 88 26 01
	00 00		 movzx	 ecx, BYTE PTR [eax+294]
  00280	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00286	85 c9		 test	 ecx, ecx
  00288	74 18		 je	 SHORT $L84893
$L84894:

; 368  : 			m_FlightControls.fBrake += 1.0f ;

  0028a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0028d	d9 80 b0 08 00
	00		 fld	 DWORD PTR [eax+2224]
  00293	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00299	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0029c	d9 99 b0 08 00
	00		 fstp	 DWORD PTR [ecx+2224]
$L84893:

; 369  : 		
; 370  : 		if( m_bKB_Cur[ DIK_LSHIFT ] & 0x80 || m_bKB_Cur[ DIK_UP ] & 0x80 )

  002a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002a5	0f b6 88 32 01
	00 00		 movzx	 ecx, BYTE PTR [eax+306]
  002ac	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002b2	85 c9		 test	 ecx, ecx
  002b4	75 14		 jne	 SHORT $L84896
  002b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002b9	0f b6 88 d0 01
	00 00		 movzx	 ecx, BYTE PTR [eax+464]
  002c0	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002c6	85 c9		 test	 ecx, ecx
  002c8	74 0d		 je	 SHORT $L84895
$L84896:

; 371  : 			m_FlightControls.bSteerAndRoll = TRUE ;

  002ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002cd	c7 80 d4 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2260], 1
$L84895:

; 372  : 
; 373  : 		if( m_bKB_Pressed[ DIK_W ] & 0x80 )

  002d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002da	8b 88 4c 02 00
	00		 mov	 ecx, DWORD PTR [eax+588]
  002e0	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002e6	85 c9		 test	 ecx, ecx
  002e8	74 0d		 je	 SHORT $L84897

; 374  : 			m_FlightControls.bNextWeapon = TRUE ;

  002ea	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002ed	c7 80 d8 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2264], 1
$L84897:

; 375  : 
; 376  : 	//
; 377  : 	// Map function keys:
; 378  : 	//
; 379  : 		if (m_bKB_Cur[DIK_F1] & 0x80)

  002f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002fa	0f b6 88 43 01
	00 00		 movzx	 ecx, BYTE PTR [eax+323]
  00301	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00307	85 c9		 test	 ecx, ecx
  00309	74 0d		 je	 SHORT $L84898

; 380  : 			m_bF1 = TRUE ;

  0030b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0030e	c7 80 0c 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1548], 1
$L84898:

; 381  : 		if (m_bKB_Cur[DIK_F2] & 0x80)

  00318	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0031b	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  00322	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00328	85 c9		 test	 ecx, ecx
  0032a	74 0d		 je	 SHORT $L84899

; 382  : 			m_bF2 = TRUE ;

  0032c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0032f	c7 80 10 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1552], 1
$L84899:

; 383  : 		if (m_bKB_Cur[DIK_F3] & 0x80)

  00339	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0033c	0f b6 88 45 01
	00 00		 movzx	 ecx, BYTE PTR [eax+325]
  00343	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00349	85 c9		 test	 ecx, ecx
  0034b	74 0d		 je	 SHORT $L84900

; 384  : 			m_bF3 = TRUE ;

  0034d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00350	c7 80 14 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1556], 1
$L84900:

; 385  : 		if (m_bKB_Cur[DIK_F4] & 0x80)

  0035a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0035d	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  00364	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0036a	85 c9		 test	 ecx, ecx
  0036c	74 0d		 je	 SHORT $L84901

; 386  : 			m_bF4 = TRUE ;

  0036e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00371	c7 80 18 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1560], 1
$L84901:

; 387  : 		if (m_bKB_Cur[DIK_F5] & 0x80)

  0037b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0037e	0f b6 88 47 01
	00 00		 movzx	 ecx, BYTE PTR [eax+327]
  00385	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0038b	85 c9		 test	 ecx, ecx
  0038d	74 0d		 je	 SHORT $L84902

; 388  : 			m_bF5 = TRUE ;

  0038f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00392	c7 80 1c 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1564], 1
$L84902:

; 389  : 		if (m_bKB_Cur[DIK_F6] & 0x80)

  0039c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0039f	0f b6 88 48 01
	00 00		 movzx	 ecx, BYTE PTR [eax+328]
  003a6	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  003ac	85 c9		 test	 ecx, ecx
  003ae	74 0d		 je	 SHORT $L84903

; 390  : 			m_bF6 = TRUE ;

  003b0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003b3	c7 80 20 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1568], 1
$L84903:

; 391  : 		if (m_bKB_Cur[DIK_F7] & 0x80)

  003bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c0	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  003c7	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  003cd	85 c9		 test	 ecx, ecx
  003cf	74 0d		 je	 SHORT $L84904

; 392  : 			m_bF7 = TRUE ;

  003d1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d4	c7 80 24 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1572], 1
$L84904:

; 393  : 		if (m_bKB_Cur[DIK_F8] & 0x80)

  003de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e1	0f b6 88 4a 01
	00 00		 movzx	 ecx, BYTE PTR [eax+330]
  003e8	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  003ee	85 c9		 test	 ecx, ecx
  003f0	74 0d		 je	 SHORT $L84905

; 394  : 			m_bF8 = TRUE ;

  003f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f5	c7 80 28 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1576], 1
$L84905:

; 395  : 		if (m_bKB_Cur[DIK_F9] & 0x80)

  003ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00402	0f b6 88 4b 01
	00 00		 movzx	 ecx, BYTE PTR [eax+331]
  00409	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0040f	85 c9		 test	 ecx, ecx
  00411	74 0d		 je	 SHORT $L84906

; 396  : 			m_bF9 = TRUE ;

  00413	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00416	c7 80 2c 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1580], 1
$L84906:

; 397  : 		if (m_bKB_Cur[DIK_F10] & 0x80)

  00420	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00423	0f b6 88 4c 01
	00 00		 movzx	 ecx, BYTE PTR [eax+332]
  0042a	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00430	85 c9		 test	 ecx, ecx
  00432	74 0d		 je	 SHORT $L84907

; 398  : 			m_bF10 = TRUE ;

  00434	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00437	c7 80 30 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1584], 1
$L84907:

; 399  : 		if (m_bKB_Cur[DIK_F11] & 0x80)

  00441	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00444	0f b6 88 5f 01
	00 00		 movzx	 ecx, BYTE PTR [eax+351]
  0044b	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00451	85 c9		 test	 ecx, ecx
  00453	74 0d		 je	 SHORT $L84908

; 400  : 			m_bF11 = TRUE ;

  00455	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00458	c7 80 34 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1588], 1
$L84908:

; 401  : 		if (m_bKB_Cur[DIK_F12] & 0x80)

  00462	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00465	0f b6 88 60 01
	00 00		 movzx	 ecx, BYTE PTR [eax+352]
  0046c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00472	85 c9		 test	 ecx, ecx
  00474	74 0d		 je	 SHORT $L84909

; 402  : 			m_bF12 = TRUE ;

  00476	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00479	c7 80 38 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1592], 1
$L84909:

; 403  : 
; 404  : 	//
; 405  : 	// Map any key:
; 406  : 	//
; 407  : 		for (int i = 0 ; i < 256 ; i ++)

  00483	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$84910[ebp], 0
  0048a	eb 09		 jmp	 SHORT $L84911
$L84912:
  0048c	8b 45 e0	 mov	 eax, DWORD PTR _i$84910[ebp]
  0048f	83 c0 01	 add	 eax, 1
  00492	89 45 e0	 mov	 DWORD PTR _i$84910[ebp], eax
$L84911:
  00495	81 7d e0 00 01
	00 00		 cmp	 DWORD PTR _i$84910[ebp], 256 ; 00000100H
  0049c	7d 28		 jge	 SHORT $L84913

; 408  : 			if (m_bKB_Cur[i] & 0x80)

  0049e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004a1	03 45 e0	 add	 eax, DWORD PTR _i$84910[ebp]
  004a4	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  004ab	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  004b1	85 c9		 test	 ecx, ecx
  004b3	74 0f		 je	 SHORT $L84914

; 409  : 			{
; 410  : 				m_bAnyKey = TRUE ;

  004b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004b8	c7 80 3c 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1596], 1

; 411  : 				break ;

  004c2	eb 02		 jmp	 SHORT $L84913
$L84914:

; 412  : 			}
; 413  : 
; 414  : 	//
; 415  : 	// Code for detecting *single* key presses:
; 416  : 	//
; 417  : 		if (m_bGotPrevKBBuf)

  004c4	eb c6		 jmp	 SHORT $L84912
$L84913:
  004c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004c9	83 b8 08 06 00
	00 00		 cmp	 DWORD PTR [eax+1544], 0
  004d0	74 6c		 je	 SHORT $L84915

; 418  : 		{
; 419  : 			for (int i = 0 ; i < 256 ; i ++)

  004d2	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$84916[ebp], 0
  004d9	eb 09		 jmp	 SHORT $L84917
$L84918:
  004db	8b 45 d4	 mov	 eax, DWORD PTR _i$84916[ebp]
  004de	83 c0 01	 add	 eax, 1
  004e1	89 45 d4	 mov	 DWORD PTR _i$84916[ebp], eax
$L84917:
  004e4	81 7d d4 00 01
	00 00		 cmp	 DWORD PTR _i$84916[ebp], 256 ; 00000100H
  004eb	7d 51		 jge	 SHORT $L84915

; 420  : 				// if pressed now, but not pressed previously;
; 421  : 				if ((m_bKB_Cur[i] & 0x80) && !(m_bKB_Prev[i] & 0x80))

  004ed	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004f0	03 45 d4	 add	 eax, DWORD PTR _i$84916[ebp]
  004f3	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  004fa	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00500	85 c9		 test	 ecx, ecx
  00502	74 27		 je	 SHORT $L84920
  00504	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00507	03 45 d4	 add	 eax, DWORD PTR _i$84916[ebp]
  0050a	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0050e	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00514	85 c9		 test	 ecx, ecx
  00516	75 13		 jne	 SHORT $L84920

; 422  : 					m_bKB_Pressed[i] = TRUE ;

  00518	8b 45 d4	 mov	 eax, DWORD PTR _i$84916[ebp]
  0051b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0051e	c7 84 81 08 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+520], 1

; 423  : 				else

  00529	eb 11		 jmp	 SHORT $L84921
$L84920:

; 424  : 					m_bKB_Pressed[i] = FALSE ;

  0052b	8b 45 d4	 mov	 eax, DWORD PTR _i$84916[ebp]
  0052e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00531	c7 84 81 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+520], 0
$L84921:
  0053c	eb 9d		 jmp	 SHORT $L84918
$L84915:

; 425  : 		}
; 426  : 		memcpy(m_bKB_Prev, m_bKB_Cur, sizeof(m_bKB_Cur)) ;

  0053e	68 00 01 00 00	 push	 256			; 00000100H
  00543	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00546	05 08 01 00 00	 add	 eax, 264		; 00000108H
  0054b	50		 push	 eax
  0054c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0054f	83 c1 08	 add	 ecx, 8
  00552	51		 push	 ecx
  00553	e8 00 00 00 00	 call	 _memcpy
  00558	83 c4 0c	 add	 esp, 12			; 0000000cH

; 427  : 		m_bGotPrevKBBuf = TRUE ;

  0055b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0055e	c7 80 08 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1544], 1

; 428  : 
; 429  : 		return S_OK ;

  00568	33 c0		 xor	 eax, eax
$L84873:

; 430  : 	}

  0056a	5f		 pop	 edi
  0056b	5e		 pop	 esi
  0056c	5b		 pop	 ebx
  0056d	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00573	3b ec		 cmp	 ebp, esp
  00575	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0057a	8b e5		 mov	 esp, ebp
  0057c	5d		 pop	 ebp
  0057d	c2 04 00	 ret	 4
?PollKeyboard@CUserInput@@QAEJ_N@Z ENDP			; CUserInput::PollKeyboard
_TEXT	ENDS
EXTRN	_fabs:NEAR
; Function compile flags: /Odt /RTCsu /ZI
; File c:\program files\microsoft visual studio .net\vc7\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv70 = -196
__X$ = 8
_fabsf	PROC NEAR					; COMDAT

; 450  :         {return ((float)fabs((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00021	83 ec 08	 sub	 esp, 8
  00024	dd 1c 24	 fstp	 QWORD PTR [esp]
  00027	e8 00 00 00 00	 call	 _fabs
  0002c	83 c4 08	 add	 esp, 8
  0002f	d9 95 3c ff ff
	ff		 fst	 DWORD PTR tv70[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_fabsf	ENDP
; Function compile flags: /Odt /RTCsu /ZI
; File c:\dxsdk\include\d3dx8math.h
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
PUBLIC	??_0D3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator/=
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
PUBLIC	__real@00000000
PUBLIC	?PollMouse@CUserInput@@QAEJ_N@Z			; CUserInput::PollMouse
;	COMDAT __real@00000000
; File c:\documents and settings\dom\my documents\_dev\ae\xlr8a\x7g\cuserinput.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?PollMouse@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT
tv398 = -336
tv384 = -336
tv370 = -336
tv356 = -336
$T85146 = -328
_fTotalWeight$ = -116
_fWeight$ = -104
_vA$ = -92
_i$ = -72
_hr$ = -60
_fMouseSensitivity$ = -48
_msMouse$ = -36
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_bInGame$ = 8
?PollMouse@CUserInput@@QAEJ_N@Z PROC NEAR		; CUserInput::PollMouse, COMDAT
; _this$ = ecx

; 440  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00013	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 441  : 		DIMOUSESTATE msMouse ;
; 442  : 		float fMouseSensitivity = 200	;		// TODO: rip out onto cmd-line, and standardize

  0002e	c7 45 d0 00 00
	48 43		 mov	 DWORD PTR _fMouseSensitivity$[ebp], 1128792064 ; 43480000H

; 443  : 												// with other inputs.
; 444  : 
; 445  : 		m_fMouseX = 0.0f ;

  00035	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 80 54 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1620], 0

; 446  : 		m_fMouseY = 0.0f ;

  00042	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c7 80 58 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1624], 0

; 447  : 		m_fMouseZ = 0.0f ;

  0004f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 80 5c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1628], 0

; 448  : 		m_bMouseLB = FALSE ;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 80 60 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1632], 0

; 449  : 		m_bMouseCB = FALSE ;

  00069	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 80 64 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1636], 0

; 450  : 		m_bMouseRB = FALSE ;

  00076	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00079	c7 80 68 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1640], 0

; 451  : 
; 452  : 	//
; 453  : 	// Get raw data:
; 454  : 	// 
; 455  : 		HRESULT hr ;
; 456  : 		if (!m_pMouse) 

  00083	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00086	83 b8 40 06 00
	00 00		 cmp	 DWORD PTR [eax+1600], 0
  0008d	75 0a		 jne	 SHORT $L84930

; 457  : 			return E_FAIL ;

  0008f	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00094	e9 61 04 00 00	 jmp	 $L84926
$L84930:

; 458  : 
; 459  : 		ZeroMemory(&msMouse, sizeof(msMouse)) ;

  00099	6a 10		 push	 16			; 00000010H
  0009b	6a 00		 push	 0
  0009d	8d 45 dc	 lea	 eax, DWORD PTR _msMouse$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _memset
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 460  : 		hr = m_pMouse->GetDeviceState(sizeof(msMouse), &msMouse) ;

  000a9	8b f4		 mov	 esi, esp
  000ab	8d 45 dc	 lea	 eax, DWORD PTR _msMouse$[ebp]
  000ae	50		 push	 eax
  000af	6a 10		 push	 16			; 00000010H
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000c3	8b 12		 mov	 edx, DWORD PTR [edx]
  000c5	51		 push	 ecx
  000c6	ff 52 24	 call	 DWORD PTR [edx+36]
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 461  : 		if (FAILED(hr)) 

  000d3	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d7	7d 5d		 jge	 SHORT $L84933

; 462  : 		{
; 463  : 			hr = m_pMouse->Acquire() ;

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000e2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  000eb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ed	8b f4		 mov	 esi, esp
  000ef	50		 push	 eax
  000f0	ff 51 1c	 call	 DWORD PTR [ecx+28]
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
$L84935:

; 464  : 			while (hr == DIERR_INPUTLOST) 

  000fd	81 7d c4 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  00104	75 26		 jne	 SHORT $L84936

; 465  : 				hr = m_pMouse->Acquire() ;

  00106	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  0010f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00112	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00118	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0011a	8b f4		 mov	 esi, esp
  0011c	50		 push	 eax
  0011d	ff 51 1c	 call	 DWORD PTR [ecx+28]
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
  0012a	eb d1		 jmp	 SHORT $L84935
$L84936:

; 466  : 
; 467  : 			return E_FAIL ;

  0012c	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00131	e9 c4 03 00 00	 jmp	 $L84926
$L84933:

; 468  : 		}
; 469  : 
; 470  : 	//
; 471  : 	// Mouse-smoothing:
; 472  : 	//
; 473  : 		int i ;
; 474  : 		xVec3 vA = xVec3( 0,0,0 );

  00136	6a 00		 push	 0
  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  0013f	e8 00 00 00 00	 call	 ??0D3DXVECTOR3@@QAE@MMM@Z ; D3DXVECTOR3::D3DXVECTOR3

; 475  : 		// move historical data through the buffer
; 476  : 		for (i = MOUSE_HISTORY_BUF - 2 ; i >= 0 ; i --)

  00144	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR _i$[ebp], -1
  0014b	eb 09		 jmp	 SHORT $L84945
$L84946:
  0014d	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00150	83 e8 01	 sub	 eax, 1
  00153	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$L84945:
  00156	83 7d b8 00	 cmp	 DWORD PTR _i$[ebp], 0
  0015a	7c 35		 jl	 SHORT $L84947

; 477  : 			m_vMouseHistory[i+1] = m_vMouseHistory[i] ;

  0015c	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0015f	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00162	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	8d 94 01 44 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1604]
  0016c	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0016f	83 c0 01	 add	 eax, 1
  00172	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	8d 84 01 44 06
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1604]
  0017f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00181	89 08		 mov	 DWORD PTR [eax], ecx
  00183	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00186	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00189	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0018c	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0018f	eb bc		 jmp	 SHORT $L84946
$L84947:

; 478  : 
; 479  : 		// drop the new data into the front of the history buffer
; 480  : 		m_vMouseHistory[0].x = +(float)msMouse.lX ;

  00191	db 45 dc	 fild	 DWORD PTR _msMouse$[ebp]
  00194	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00197	d9 98 44 06 00
	00		 fstp	 DWORD PTR [eax+1604]

; 481  : 		m_vMouseHistory[0].y = -(float)msMouse.lY ;

  0019d	db 45 e0	 fild	 DWORD PTR _msMouse$[ebp+4]
  001a0	d9 e0		 fchs
  001a2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	d9 98 48 06 00
	00		 fstp	 DWORD PTR [eax+1608]

; 482  : 		m_vMouseHistory[0].z = +(float)msMouse.lZ ;

  001ab	db 45 e4	 fild	 DWORD PTR _msMouse$[ebp+8]
  001ae	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	d9 98 4c 06 00
	00		 fstp	 DWORD PTR [eax+1612]

; 483  : 
; 484  : 		// get weighted average from the buffer
; 485  : 		float fWeight = 1.0f, fTotalWeight = 0.0f ;

  001b7	c7 45 98 00 00
	80 3f		 mov	 DWORD PTR _fWeight$[ebp], 1065353216 ; 3f800000H
  001be	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _fTotalWeight$[ebp], 0

; 486  : 		for (i = 0 ; i < MOUSE_HISTORY_BUF ; i ++)

  001c5	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001cc	eb 09		 jmp	 SHORT $L84953
$L84954:
  001ce	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  001d1	83 c0 01	 add	 eax, 1
  001d4	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$L84953:
  001d7	83 7d b8 01	 cmp	 DWORD PTR _i$[ebp], 1
  001db	7d 40		 jge	 SHORT $L84955

; 487  : 		{
; 488  : 			vA += m_vMouseHistory[i] * fWeight ;

  001dd	8b 45 98	 mov	 eax, DWORD PTR _fWeight$[ebp]
  001e0	50		 push	 eax
  001e1	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T85146[ebp]
  001e7	51		 push	 ecx
  001e8	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  001eb	6b d2 0c	 imul	 edx, 12			; 0000000cH
  001ee	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	8d 8c 10 44 06
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1604]
  001f8	e8 00 00 00 00	 call	 ??DD3DXVECTOR3@@QBE?AU0@M@Z ; D3DXVECTOR3::operator*
  001fd	50		 push	 eax
  001fe	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  00201	e8 00 00 00 00	 call	 ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ; D3DXVECTOR3::operator+=

; 489  : 			fTotalWeight += fWeight ;

  00206	d9 45 8c	 fld	 DWORD PTR _fTotalWeight$[ebp]
  00209	d8 45 98	 fadd	 DWORD PTR _fWeight$[ebp]
  0020c	d9 5d 8c	 fstp	 DWORD PTR _fTotalWeight$[ebp]

; 490  : 			fWeight *= MOUSE_SMOOTH_WEIGHT_D ;

  0020f	d9 45 98	 fld	 DWORD PTR _fWeight$[ebp]
  00212	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f800000
  00218	d9 5d 98	 fstp	 DWORD PTR _fWeight$[ebp]

; 491  : 		}

  0021b	eb b1		 jmp	 SHORT $L84954
$L84955:

; 492  : 		vA /= fTotalWeight ; //(float)MOUSE_HISTORY_BUF ;

  0021d	8b 45 8c	 mov	 eax, DWORD PTR _fTotalWeight$[ebp]
  00220	50		 push	 eax
  00221	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  00224	e8 00 00 00 00	 call	 ??_0D3DXVECTOR3@@QAEAAU0@M@Z ; D3DXVECTOR3::operator/=

; 493  : 
; 494  : 		vA.x = +(float)msMouse.lX ;

  00229	db 45 dc	 fild	 DWORD PTR _msMouse$[ebp]
  0022c	d9 5d a4	 fstp	 DWORD PTR _vA$[ebp]

; 495  : 		vA.y = -(float)msMouse.lY ;

  0022f	db 45 e0	 fild	 DWORD PTR _msMouse$[ebp+4]
  00232	d9 e0		 fchs
  00234	d9 5d a8	 fstp	 DWORD PTR _vA$[ebp+4]

; 496  : 		vA.z = +(float)msMouse.lZ ;

  00237	db 45 e4	 fild	 DWORD PTR _msMouse$[ebp+8]
  0023a	d9 5d ac	 fstp	 DWORD PTR _vA$[ebp+8]

; 497  : 
; 498  : 	//
; 499  : 	// Map Movement:
; 500  : 	//
; 501  : 		m_fMouseX = vA.x ;

  0023d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00240	8b 4d a4	 mov	 ecx, DWORD PTR _vA$[ebp]
  00243	89 88 54 06 00
	00		 mov	 DWORD PTR [eax+1620], ecx

; 502  : 		m_fMouseY = vA.y ;

  00249	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0024c	8b 4d a8	 mov	 ecx, DWORD PTR _vA$[ebp+4]
  0024f	89 88 58 06 00
	00		 mov	 DWORD PTR [eax+1624], ecx

; 503  : 		m_fMouseZ = vA.z ;

  00255	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00258	8b 4d ac	 mov	 ecx, DWORD PTR _vA$[ebp+8]
  0025b	89 88 5c 06 00
	00		 mov	 DWORD PTR [eax+1628], ecx

; 504  : 
; 505  : 		if (vA.x < 0.0f)

  00261	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  00264	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0026a	df e0		 fnstsw	 ax
  0026c	f6 c4 05	 test	 ah, 5
  0026f	7a 4f		 jp	 SHORT $L84960

; 506  : 		{
; 507  : 			m_FlightControls.fSteerLeft += (float)fabs(vA.x) * fMouseSensitivity ;

  00271	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  00274	83 ec 08	 sub	 esp, 8
  00277	dd 1c 24	 fstp	 QWORD PTR [esp]
  0027a	e8 00 00 00 00	 call	 _fabs
  0027f	83 c4 08	 add	 esp, 8
  00282	d9 95 b0 fe ff
	ff		 fst	 DWORD PTR tv356[ebp]
  00288	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  0028b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0028e	d8 80 b4 08 00
	00		 fadd	 DWORD PTR [eax+2228]
  00294	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	d9 99 b4 08 00
	00		 fstp	 DWORD PTR [ecx+2228]

; 508  : 			if (m_FlightControls.fSteerLeft > MAX_FLIGHTMAP)

  0029d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	d9 80 b4 08 00
	00		 fld	 DWORD PTR [eax+2228]
  002a6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  002ac	df e0		 fnstsw	 ax
  002ae	f6 c4 41	 test	 ah, 65			; 00000041H
  002b1	75 0d		 jne	 SHORT $L84960

; 509  : 				m_FlightControls.fSteerLeft = MAX_FLIGHTMAP ;

  002b3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002b6	c7 80 b4 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2228], 1101004800 ; 41a00000H
$L84960:

; 510  : 		}
; 511  : 		if (vA.x > 0.0f)

  002c0	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  002c3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  002c9	df e0		 fnstsw	 ax
  002cb	f6 c4 41	 test	 ah, 65			; 00000041H
  002ce	75 4f		 jne	 SHORT $L84963

; 512  : 		{
; 513  : 			m_FlightControls.fSteerRight += (float)fabs(vA.x) * fMouseSensitivity ;

  002d0	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  002d3	83 ec 08	 sub	 esp, 8
  002d6	dd 1c 24	 fstp	 QWORD PTR [esp]
  002d9	e8 00 00 00 00	 call	 _fabs
  002de	83 c4 08	 add	 esp, 8
  002e1	d9 95 b0 fe ff
	ff		 fst	 DWORD PTR tv370[ebp]
  002e7	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  002ea	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002ed	d8 80 b8 08 00
	00		 fadd	 DWORD PTR [eax+2232]
  002f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	d9 99 b8 08 00
	00		 fstp	 DWORD PTR [ecx+2232]

; 514  : 			if (m_FlightControls.fSteerRight > MAX_FLIGHTMAP)

  002fc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002ff	d9 80 b8 08 00
	00		 fld	 DWORD PTR [eax+2232]
  00305	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  0030b	df e0		 fnstsw	 ax
  0030d	f6 c4 41	 test	 ah, 65			; 00000041H
  00310	75 0d		 jne	 SHORT $L84963

; 515  : 				m_FlightControls.fSteerRight = MAX_FLIGHTMAP ;

  00312	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00315	c7 80 b8 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2232], 1101004800 ; 41a00000H
$L84963:

; 516  : 		}
; 517  : 		if (vA.y < 0.0f)

  0031f	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00322	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00328	df e0		 fnstsw	 ax
  0032a	f6 c4 05	 test	 ah, 5
  0032d	7a 4f		 jp	 SHORT $L84966

; 518  : 		{
; 519  : 			m_FlightControls.fClimb += (float)fabs(vA.y) * fMouseSensitivity ;

  0032f	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00332	83 ec 08	 sub	 esp, 8
  00335	dd 1c 24	 fstp	 QWORD PTR [esp]
  00338	e8 00 00 00 00	 call	 _fabs
  0033d	83 c4 08	 add	 esp, 8
  00340	d9 95 b0 fe ff
	ff		 fst	 DWORD PTR tv384[ebp]
  00346	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  00349	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0034c	d8 80 c0 08 00
	00		 fadd	 DWORD PTR [eax+2240]
  00352	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00355	d9 99 c0 08 00
	00		 fstp	 DWORD PTR [ecx+2240]

; 520  : 			if (m_FlightControls.fClimb > MAX_FLIGHTMAP)

  0035b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0035e	d9 80 c0 08 00
	00		 fld	 DWORD PTR [eax+2240]
  00364	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  0036a	df e0		 fnstsw	 ax
  0036c	f6 c4 41	 test	 ah, 65			; 00000041H
  0036f	75 0d		 jne	 SHORT $L84966

; 521  : 				m_FlightControls.fClimb = MAX_FLIGHTMAP ;

  00371	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00374	c7 80 c0 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2240], 1101004800 ; 41a00000H
$L84966:

; 522  : 		}
; 523  : 		if (vA.y > 0.0f)

  0037e	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00381	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00387	df e0		 fnstsw	 ax
  00389	f6 c4 41	 test	 ah, 65			; 00000041H
  0038c	75 4f		 jne	 SHORT $L84969

; 524  : 		{
; 525  : 			m_FlightControls.fDive += (float)fabs(vA.y) * fMouseSensitivity ;

  0038e	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00391	83 ec 08	 sub	 esp, 8
  00394	dd 1c 24	 fstp	 QWORD PTR [esp]
  00397	e8 00 00 00 00	 call	 _fabs
  0039c	83 c4 08	 add	 esp, 8
  0039f	d9 95 b0 fe ff
	ff		 fst	 DWORD PTR tv398[ebp]
  003a5	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  003a8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003ab	d8 80 bc 08 00
	00		 fadd	 DWORD PTR [eax+2236]
  003b1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003b4	d9 99 bc 08 00
	00		 fstp	 DWORD PTR [ecx+2236]

; 526  : 			if (m_FlightControls.fDive > MAX_FLIGHTMAP)

  003ba	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003bd	d9 80 bc 08 00
	00		 fld	 DWORD PTR [eax+2236]
  003c3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  003c9	df e0		 fnstsw	 ax
  003cb	f6 c4 41	 test	 ah, 65			; 00000041H
  003ce	75 0d		 jne	 SHORT $L84969

; 527  : 				m_FlightControls.fDive = MAX_FLIGHTMAP ;

  003d0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003d3	c7 80 bc 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2236], 1101004800 ; 41a00000H
$L84969:

; 528  : 		}
; 529  : 
; 530  : 	//
; 531  : 	// Map Buttons:
; 532  : 	//
; 533  : 		m_bMouseLB = msMouse.rgbButtons[0] & 0x80 ;

  003dd	0f b6 45 e8	 movzx	 eax, BYTE PTR _msMouse$[ebp+12]
  003e1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003e6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003e9	89 81 60 06 00
	00		 mov	 DWORD PTR [ecx+1632], eax

; 534  : 		m_bMouseRB = msMouse.rgbButtons[1] & 0x80 ;

  003ef	0f b6 45 e9	 movzx	 eax, BYTE PTR _msMouse$[ebp+13]
  003f3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003f8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	89 81 68 06 00
	00		 mov	 DWORD PTR [ecx+1640], eax

; 535  : 		m_bMouseCB = msMouse.rgbButtons[2] & 0x80 ;

  00401	0f b6 45 ea	 movzx	 eax, BYTE PTR _msMouse$[ebp+14]
  00405	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0040a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0040d	89 81 64 06 00
	00		 mov	 DWORD PTR [ecx+1636], eax

; 536  : 		
; 537  : 		if( m_bMouseLB )

  00413	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00416	83 b8 60 06 00
	00 00		 cmp	 DWORD PTR [eax+1632], 0
  0041d	74 0d		 je	 SHORT $L84972

; 538  : 			m_FlightControls.bFireA = TRUE ;

  0041f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00422	c7 80 e0 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2272], 1
$L84972:

; 539  : 
; 540  : 		if( m_bMouseRB )

  0042c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0042f	83 b8 68 06 00
	00 00		 cmp	 DWORD PTR [eax+1640], 0
  00436	74 0d		 je	 SHORT $L84973

; 541  : 			m_FlightControls.bFireB = TRUE ;

  00438	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0043b	c7 80 e4 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2276], 1
$L84973:

; 542  : 
; 543  : 	//
; 544  : 	// Map any change in rollwheel:
; 545  : 	//
; 546  : 		if( m_fMouseZ != m_fMousePrevZ && m_bScanForChangeInMouseWheel )

  00445	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00448	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0044b	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  00451	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  00457	df e0		 fnstsw	 ax
  00459	f6 c4 44	 test	 ah, 68			; 00000044H
  0045c	7b 65		 jnp	 SHORT $L84974
  0045e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00461	83 b8 70 06 00
	00 00		 cmp	 DWORD PTR [eax+1648], 0
  00468	74 59		 je	 SHORT $L84974

; 547  : 		{
; 548  : 			if( m_fMouseZ < m_fMousePrevZ )

  0046a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0046d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00470	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  00476	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  0047c	df e0		 fnstsw	 ax
  0047e	f6 c4 05	 test	 ah, 5
  00481	7a 0d		 jp	 SHORT $L84975

; 549  : 				m_FlightControls.bNextWeapon = TRUE ;

  00483	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00486	c7 80 d8 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2264], 1
$L84975:

; 550  : 			if( m_fMouseZ > m_fMousePrevZ )

  00490	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00493	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00496	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  0049c	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  004a2	df e0		 fnstsw	 ax
  004a4	f6 c4 41	 test	 ah, 65			; 00000041H
  004a7	75 0d		 jne	 SHORT $L84976

; 551  : 				m_FlightControls.bPrevWeapon = TRUE ;

  004a9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004ac	c7 80 dc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2268], 1
$L84976:

; 552  : 			
; 553  : 			m_bScanForChangeInMouseWheel = FALSE ;

  004b6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004b9	c7 80 70 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1648], 0
$L84974:

; 554  : 		}
; 555  : 		if( m_fMouseZ == 0 )

  004c3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004c6	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  004cc	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  004d2	df e0		 fnstsw	 ax
  004d4	f6 c4 44	 test	 ah, 68			; 00000044H
  004d7	7a 0d		 jp	 SHORT $L84977

; 556  : 			m_bScanForChangeInMouseWheel = TRUE ;

  004d9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004dc	c7 80 70 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1648], 1
$L84977:

; 557  : 
; 558  : 		m_fMousePrevZ = m_fMouseZ ;

  004e6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004e9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004ec	8b 91 5c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1628]
  004f2	89 90 50 06 00
	00		 mov	 DWORD PTR [eax+1616], edx

; 559  : 
; 560  : 
; 561  : 		/*TCHAR              strElement[10] ;
; 562  : 		DIDEVICEOBJECTDATA didod[MOUSE_BUFFER_SIZE] ;
; 563  : 		DWORD              dwElements ;
; 564  : 		DWORD              i ;
; 565  : 		HRESULT            hr ;
; 566  : 
; 567  : 		if (NULL == m_pMouse) 
; 568  : 			return S_OK ;
; 569  :     
; 570  : 		dwElements = MOUSE_BUFFER_SIZE;
; 571  : 		hr = m_pMouse->GetDeviceData(sizeof(DIDEVICEOBJECTDATA), didod, &dwElements, 0) ;
; 572  : 		if (hr != DI_OK) 
; 573  : 		{
; 574  : 			// We got an error or we got DI_BUFFEROVERFLOW.
; 575  : 			//
; 576  : 			// Either way, it means that continuous contact with the
; 577  : 			// device has been lost, either due to an external
; 578  : 			// interruption, or because the buffer overflowed
; 579  : 			// and some events were lost.
; 580  : 			//
; 581  : 			// Consequently, if a button was pressed at the time
; 582  : 			// the buffer overflowed or the connection was broken,
; 583  : 			// the corresponding "up" message might have been lost.
; 584  : 			//
; 585  : 			// But since our simple sample doesn't actually have
; 586  : 			// any state associated with button up or down events,
; 587  : 			// there is no state to reset.  (In a real game, ignoring
; 588  : 			// the buffer overflow would result in the game thinking
; 589  : 			// a key was held down when in fact it isn't; it's just
; 590  : 			// that the "up" event got lost because the buffer
; 591  : 			// overflowed.)
; 592  : 			//
; 593  : 			// If we want to be cleverer, we could do a
; 594  : 			// GetDeviceState() and compare the current state
; 595  : 			// against the state we think the device is in,
; 596  : 			// and process all the states that are currently
; 597  : 			// different from our private state.
; 598  : 			hr = m_pMouse->Acquire() ;
; 599  : 			while(hr == DIERR_INPUTLOST) 
; 600  : 				hr = m_pMouse->Acquire() ;
; 601  : 
; 602  : 			// hr may be DIERR_OTHERAPPHASPRIO or other errors.  This
; 603  : 			// may occur when the app is minimized or in the process of 
; 604  : 			// switching, so just try again later 
; 605  : 			return S_OK ;
; 606  : 		}
; 607  : 
; 608  : 		if (FAILED(hr))  
; 609  : 			return hr ;
; 610  : 
; 611  : 	// study each of the buffer elements and process them
; 612  : 		for (i = 0 ; i < dwElements ; i++) 
; 613  : 		{
; 614  : 
; 615  : 			switch (didod[i].dwOfs)
; 616  : 			{
; 617  : 				case DIMOFS_BUTTON0:
; 618  : 					if (didod[i].dwData & 0x80)
; 619  : 						m_bMouseLB = FALSE ;
; 620  : 					else
; 621  : 						m_bMouseLB = TRUE ;
; 622  : 					break ;
; 623  : 
; 624  : 				case DIMOFS_BUTTON1:
; 625  : 					if (didod[i].dwData & 0x80)
; 626  : 						m_bMouseRB = FALSE ;
; 627  : 					else
; 628  : 						m_bMouseRB = TRUE ;
; 629  : 					break ;
; 630  : 
; 631  : 				case DIMOFS_BUTTON2:
; 632  : 					if (didod[i].dwData & 0x80)
; 633  : 						m_bMouseCB = FALSE ;
; 634  : 					else
; 635  : 						m_bMouseCB = TRUE ;
; 636  : 					break ;
; 637  : 
; 638  : 				case DIMOFS_BUTTON3:
; 639  : 					break;
; 640  : 
; 641  : 				case DIMOFS_X:
; 642  : 					m_fMouseX += (float)didod[i].dwData / 10.0f ;
; 643  : 					break ;
; 644  : 
; 645  : 				case DIMOFS_Y:
; 646  : 					m_fMouseX += (float)didod[i].dwData / 10.0f ;
; 647  : 					break ;
; 648  : 
; 649  : 				case DIMOFS_Z:
; 650  : 					//m_fMouseZ += (float)didod[i].dwData ;
; 651  : 					break ;
; 652  : 			}
; 653  : 		}*/
; 654  : 
; 655  : 		return S_OK ;

  004f8	33 c0		 xor	 eax, eax
$L84926:

; 656  : 	}

  004fa	52		 push	 edx
  004fb	8b cd		 mov	 ecx, ebp
  004fd	50		 push	 eax
  004fe	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85153
  00504	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00509	58		 pop	 eax
  0050a	5a		 pop	 edx
  0050b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050e	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  00511	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00516	5f		 pop	 edi
  00517	5e		 pop	 esi
  00518	5b		 pop	 ebx
  00519	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  0051f	3b ec		 cmp	 ebp, esp
  00521	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00526	8b e5		 mov	 esp, ebp
  00528	5d		 pop	 ebp
  00529	c2 04 00	 ret	 4
$L85153:
  0052c	02 00 00 00	 DD	 2
  00530	00 00 00 00	 DD	 $L85152
$L85152:
  00534	dc ff ff ff	 DD	 -36			; ffffffdcH
  00538	10 00 00 00	 DD	 16			; 00000010H
  0053c	00 00 00 00	 DD	 $L85149
  00540	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00544	0c 00 00 00	 DD	 12			; 0000000cH
  00548	00 00 00 00	 DD	 $L85150
$L85150:
  0054c	76		 DB	 118			; 00000076H
  0054d	41		 DB	 65			; 00000041H
  0054e	00		 DB	 0
$L85149:
  0054f	6d		 DB	 109			; 0000006dH
  00550	73		 DB	 115			; 00000073H
  00551	4d		 DB	 77			; 0000004dH
  00552	6f		 DB	 111			; 0000006fH
  00553	75		 DB	 117			; 00000075H
  00554	73		 DB	 115			; 00000073H
  00555	65		 DB	 101			; 00000065H
  00556	00		 DB	 0
?PollMouse@CUserInput@@QAEJ_N@Z ENDP			; CUserInput::PollMouse
_TEXT	ENDS
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?PollMouseSticky@CUserInput@@QAEJ_N@Z
_TEXT	SEGMENT
$T85157 = -328
_fTotalWeight$ = -116
_fWeight$ = -104
_vA$ = -92
_i$ = -72
_hr$ = -60
_fMouseSensitivity$ = -48
_msMouse$ = -36
_this$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_bInGame$ = 8
?PollMouseSticky@CUserInput@@QAEJ_N@Z PROC NEAR		; CUserInput::PollMouseSticky, COMDAT
; _this$ = ecx

; 668  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00013	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 669  : 		DIMOUSESTATE msMouse ;
; 670  : 		float fMouseSensitivity = 0.5f * m_fMouseSensitivity ;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00037	d8 88 84 06 00
	00		 fmul	 DWORD PTR [eax+1668]
  0003d	d9 5d d0	 fstp	 DWORD PTR _fMouseSensitivity$[ebp]

; 671  : 
; 672  : 		m_fMouseX = 0.0f ;

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 80 54 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1620], 0

; 673  : 		m_fMouseY = 0.0f ;

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 80 58 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1624], 0

; 674  : 		m_fMouseZ = 0.0f ;

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 80 5c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1628], 0

; 675  : 		m_bMouseLB = FALSE ;

  00067	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 80 60 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1632], 0

; 676  : 		m_bMouseCB = FALSE ;

  00074	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00077	c7 80 64 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1636], 0

; 677  : 		m_bMouseRB = FALSE ;

  00081	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00084	c7 80 68 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1640], 0

; 678  : 
; 679  : 	//
; 680  : 	// Get raw data:
; 681  : 	// 
; 682  : 		HRESULT hr ;
; 683  : 		if (!m_pMouse) 

  0008e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00091	83 b8 40 06 00
	00 00		 cmp	 DWORD PTR [eax+1600], 0
  00098	75 0a		 jne	 SHORT $L84986

; 684  : 			return E_FAIL ;

  0009a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0009f	e9 3b 06 00 00	 jmp	 $L84982
$L84986:

; 685  : 
; 686  : 		ZeroMemory(&msMouse, sizeof(msMouse)) ;

  000a4	6a 10		 push	 16			; 00000010H
  000a6	6a 00		 push	 0
  000a8	8d 45 dc	 lea	 eax, DWORD PTR _msMouse$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 687  : 		hr = m_pMouse->GetDeviceState(sizeof(msMouse), &msMouse) ;

  000b4	8b f4		 mov	 esi, esp
  000b6	8d 45 dc	 lea	 eax, DWORD PTR _msMouse$[ebp]
  000b9	50		 push	 eax
  000ba	6a 10		 push	 16			; 00000010H
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  000c5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000ce	8b 12		 mov	 edx, DWORD PTR [edx]
  000d0	51		 push	 ecx
  000d1	ff 52 24	 call	 DWORD PTR [edx+36]
  000d4	3b f4		 cmp	 esi, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 688  : 		if (FAILED(hr)) 

  000de	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e2	7d 5d		 jge	 SHORT $L84989

; 689  : 		{
; 690  : 			hr = m_pMouse->Acquire() ;

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000ed	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  000f6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000f8	8b f4		 mov	 esi, esp
  000fa	50		 push	 eax
  000fb	ff 51 1c	 call	 DWORD PTR [ecx+28]
  000fe	3b f4		 cmp	 esi, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
$L84991:

; 691  : 			while (hr == DIERR_INPUTLOST) 

  00108	81 7d c4 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  0010f	75 26		 jne	 SHORT $L84992

; 692  : 				hr = m_pMouse->Acquire() ;

  00111	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00114	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  0011a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00123	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00125	8b f4		 mov	 esi, esp
  00127	50		 push	 eax
  00128	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0012b	3b f4		 cmp	 esi, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00132	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax
  00135	eb d1		 jmp	 SHORT $L84991
$L84992:

; 693  : 
; 694  : 			return E_FAIL ;

  00137	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0013c	e9 9e 05 00 00	 jmp	 $L84982
$L84989:

; 695  : 		}
; 696  : 
; 697  : 	//
; 698  : 	// Mouse invert:
; 699  : 	//
; 700  : 		if( m_bMouseInvert )

  00141	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00144	0f b6 88 88 06
	00 00		 movzx	 ecx, BYTE PTR [eax+1672]
  0014b	85 c9		 test	 ecx, ecx
  0014d	74 09		 je	 SHORT $L84998

; 701  : 			msMouse.lY *= -1 ;

  0014f	8b 45 e0	 mov	 eax, DWORD PTR _msMouse$[ebp+4]
  00152	6b c0 ff	 imul	 eax, -1
  00155	89 45 e0	 mov	 DWORD PTR _msMouse$[ebp+4], eax
$L84998:

; 702  : 
; 703  : 	//
; 704  : 	// Mouse-smoothing:
; 705  : 	//
; 706  : 		int i ;
; 707  : 		xVec3 vA = xVec3( 0,0,0 );

  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	6a 00		 push	 0
  0015e	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  00161	e8 00 00 00 00	 call	 ??0D3DXVECTOR3@@QAE@MMM@Z ; D3DXVECTOR3::D3DXVECTOR3

; 708  : 		// move historical data through the buffer
; 709  : 		for (i = MOUSE_HISTORY_BUF - 2 ; i >= 0 ; i --)

  00166	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR _i$[ebp], -1
  0016d	eb 09		 jmp	 SHORT $L85002
$L85003:
  0016f	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00172	83 e8 01	 sub	 eax, 1
  00175	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$L85002:
  00178	83 7d b8 00	 cmp	 DWORD PTR _i$[ebp], 0
  0017c	7c 35		 jl	 SHORT $L85004

; 710  : 			m_vMouseHistory[i+1] = m_vMouseHistory[i] ;

  0017e	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00181	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00184	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	8d 94 01 44 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1604]
  0018e	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00191	83 c0 01	 add	 eax, 1
  00194	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00197	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	8d 84 01 44 06
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1604]
  001a1	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001a3	89 08		 mov	 DWORD PTR [eax], ecx
  001a5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001a8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001ab	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  001ae	89 50 08	 mov	 DWORD PTR [eax+8], edx
  001b1	eb bc		 jmp	 SHORT $L85003
$L85004:

; 711  : 
; 712  : 		// drop the new data into the front of the history buffer
; 713  : 		m_vMouseHistory[0].x = +(float)msMouse.lX ;

  001b3	db 45 dc	 fild	 DWORD PTR _msMouse$[ebp]
  001b6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	d9 98 44 06 00
	00		 fstp	 DWORD PTR [eax+1604]

; 714  : 		m_vMouseHistory[0].y = -(float)msMouse.lY ;

  001bf	db 45 e0	 fild	 DWORD PTR _msMouse$[ebp+4]
  001c2	d9 e0		 fchs
  001c4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	d9 98 48 06 00
	00		 fstp	 DWORD PTR [eax+1608]

; 715  : 		m_vMouseHistory[0].z = +(float)msMouse.lZ ;

  001cd	db 45 e4	 fild	 DWORD PTR _msMouse$[ebp+8]
  001d0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	d9 98 4c 06 00
	00		 fstp	 DWORD PTR [eax+1612]

; 716  : 
; 717  : 		// get weighted average from the buffer
; 718  : 		float fWeight = 1.0f, fTotalWeight = 0.0f ;

  001d9	c7 45 98 00 00
	80 3f		 mov	 DWORD PTR _fWeight$[ebp], 1065353216 ; 3f800000H
  001e0	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _fTotalWeight$[ebp], 0

; 719  : 		for (i = 0 ; i < MOUSE_HISTORY_BUF ; i ++)

  001e7	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001ee	eb 09		 jmp	 SHORT $L85010
$L85011:
  001f0	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  001f3	83 c0 01	 add	 eax, 1
  001f6	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$L85010:
  001f9	83 7d b8 01	 cmp	 DWORD PTR _i$[ebp], 1
  001fd	7d 40		 jge	 SHORT $L85012

; 720  : 		{
; 721  : 			vA += m_vMouseHistory[i] * fWeight ;

  001ff	8b 45 98	 mov	 eax, DWORD PTR _fWeight$[ebp]
  00202	50		 push	 eax
  00203	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T85157[ebp]
  00209	51		 push	 ecx
  0020a	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  0020d	6b d2 0c	 imul	 edx, 12			; 0000000cH
  00210	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00213	8d 8c 10 44 06
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1604]
  0021a	e8 00 00 00 00	 call	 ??DD3DXVECTOR3@@QBE?AU0@M@Z ; D3DXVECTOR3::operator*
  0021f	50		 push	 eax
  00220	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  00223	e8 00 00 00 00	 call	 ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ; D3DXVECTOR3::operator+=

; 722  : 			fTotalWeight += fWeight ;

  00228	d9 45 8c	 fld	 DWORD PTR _fTotalWeight$[ebp]
  0022b	d8 45 98	 fadd	 DWORD PTR _fWeight$[ebp]
  0022e	d9 5d 8c	 fstp	 DWORD PTR _fTotalWeight$[ebp]

; 723  : 			fWeight *= MOUSE_SMOOTH_WEIGHT_D ;

  00231	d9 45 98	 fld	 DWORD PTR _fWeight$[ebp]
  00234	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f800000
  0023a	d9 5d 98	 fstp	 DWORD PTR _fWeight$[ebp]

; 724  : 		}

  0023d	eb b1		 jmp	 SHORT $L85011
$L85012:

; 725  : 		vA /= fTotalWeight ; //(float)MOUSE_HISTORY_BUF ;

  0023f	8b 45 8c	 mov	 eax, DWORD PTR _fTotalWeight$[ebp]
  00242	50		 push	 eax
  00243	8d 4d a4	 lea	 ecx, DWORD PTR _vA$[ebp]
  00246	e8 00 00 00 00	 call	 ??_0D3DXVECTOR3@@QAEAAU0@M@Z ; D3DXVECTOR3::operator/=

; 726  : 		
; 727  : 	
; 728  : 	// no mouse smoothing at all!
; 729  : 		vA.x = +(float)msMouse.lX ;

  0024b	db 45 dc	 fild	 DWORD PTR _msMouse$[ebp]
  0024e	d9 5d a4	 fstp	 DWORD PTR _vA$[ebp]

; 730  : 		vA.y = -(float)msMouse.lY ;

  00251	db 45 e0	 fild	 DWORD PTR _msMouse$[ebp+4]
  00254	d9 e0		 fchs
  00256	d9 5d a8	 fstp	 DWORD PTR _vA$[ebp+4]

; 731  : 		vA.z = +(float)msMouse.lZ ;

  00259	db 45 e4	 fild	 DWORD PTR _msMouse$[ebp+8]
  0025c	d9 5d ac	 fstp	 DWORD PTR _vA$[ebp+8]

; 732  : 		m_fMouseX = vA.x ;

  0025f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00262	8b 4d a4	 mov	 ecx, DWORD PTR _vA$[ebp]
  00265	89 88 54 06 00
	00		 mov	 DWORD PTR [eax+1620], ecx

; 733  : 		m_fMouseY = vA.y ;

  0026b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0026e	8b 4d a8	 mov	 ecx, DWORD PTR _vA$[ebp+4]
  00271	89 88 58 06 00
	00		 mov	 DWORD PTR [eax+1624], ecx

; 734  : 		m_fMouseZ = vA.z ;

  00277	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0027a	8b 4d ac	 mov	 ecx, DWORD PTR _vA$[ebp+8]
  0027d	89 88 5c 06 00
	00		 mov	 DWORD PTR [eax+1628], ecx

; 735  : 		
; 736  : 	//
; 737  : 	// Map Movement:
; 738  : 	//
; 739  : 		if( vA.x != 0 || vA.y != 0 || vA.z != 0 )

  00283	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  00286	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0028c	df e0		 fnstsw	 ax
  0028e	f6 c4 44	 test	 ah, 68			; 00000044H
  00291	7a 20		 jp	 SHORT $L85018
  00293	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00296	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0029c	df e0		 fnstsw	 ax
  0029e	f6 c4 44	 test	 ah, 68			; 00000044H
  002a1	7a 10		 jp	 SHORT $L85018
  002a3	d9 45 ac	 fld	 DWORD PTR _vA$[ebp+8]
  002a6	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  002ac	df e0		 fnstsw	 ax
  002ae	f6 c4 44	 test	 ah, 68			; 00000044H
  002b1	7b 3f		 jnp	 SHORT $L85017
$L85018:

; 740  : 		{
; 741  : 			m_fMouseStickyX += vA.x ;

  002b3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002b6	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  002b9	d8 80 74 06 00
	00		 fadd	 DWORD PTR [eax+1652]
  002bf	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	d9 99 74 06 00
	00		 fstp	 DWORD PTR [ecx+1652]

; 742  : 			m_fMouseStickyY += vA.y ;

  002c8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002cb	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  002ce	d8 80 78 06 00
	00		 fadd	 DWORD PTR [eax+1656]
  002d4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	d9 99 78 06 00
	00		 fstp	 DWORD PTR [ecx+1656]

; 743  : 			m_fMouseStickyZ += vA.z ;

  002dd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	d9 45 ac	 fld	 DWORD PTR _vA$[ebp+8]
  002e3	d8 80 7c 06 00
	00		 fadd	 DWORD PTR [eax+1660]
  002e9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002ec	d9 99 7c 06 00
	00		 fstp	 DWORD PTR [ecx+1660]
$L85017:

; 744  : 			//ods( "%0.1f,%0.1f,%0.1f\n", m_fMouseStickyX, m_fMouseStickyY, m_fMouseStickyZ );
; 745  : 		}
; 746  : 
; 747  : 	// allow quick changes of direction, to more properly emulate a joystick.
; 748  : 		if( vA.x < 0 && m_fMouseStickyX > 0 ) m_fMouseStickyX *= 0.5f ;

  002f2	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  002f5	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  002fb	df e0		 fnstsw	 ax
  002fd	f6 c4 05	 test	 ah, 5
  00300	7a 2e		 jp	 SHORT $L85019
  00302	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00305	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  0030b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00311	df e0		 fnstsw	 ax
  00313	f6 c4 41	 test	 ah, 65			; 00000041H
  00316	75 18		 jne	 SHORT $L85019
  00318	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0031b	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  00321	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00327	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0032a	d9 99 74 06 00
	00		 fstp	 DWORD PTR [ecx+1652]
$L85019:

; 749  : 		if( vA.x > 0 && m_fMouseStickyX < 0 ) m_fMouseStickyX *= 0.5f ;

  00330	d9 45 a4	 fld	 DWORD PTR _vA$[ebp]
  00333	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00339	df e0		 fnstsw	 ax
  0033b	f6 c4 41	 test	 ah, 65			; 00000041H
  0033e	75 2e		 jne	 SHORT $L85020
  00340	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00343	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  00349	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0034f	df e0		 fnstsw	 ax
  00351	f6 c4 05	 test	 ah, 5
  00354	7a 18		 jp	 SHORT $L85020
  00356	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00359	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  0035f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00365	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00368	d9 99 74 06 00
	00		 fstp	 DWORD PTR [ecx+1652]
$L85020:

; 750  : 		if( vA.y < 0 && m_fMouseStickyY > 0 ) m_fMouseStickyY *= 0.5f ;

  0036e	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  00371	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00377	df e0		 fnstsw	 ax
  00379	f6 c4 05	 test	 ah, 5
  0037c	7a 2e		 jp	 SHORT $L85021
  0037e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00381	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  00387	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0038d	df e0		 fnstsw	 ax
  0038f	f6 c4 41	 test	 ah, 65			; 00000041H
  00392	75 18		 jne	 SHORT $L85021
  00394	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00397	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  0039d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  003a3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	d9 99 78 06 00
	00		 fstp	 DWORD PTR [ecx+1656]
$L85021:

; 751  : 		if( vA.y > 0 && m_fMouseStickyY < 0 ) m_fMouseStickyY *= 0.5f ;

  003ac	d9 45 a8	 fld	 DWORD PTR _vA$[ebp+4]
  003af	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  003b5	df e0		 fnstsw	 ax
  003b7	f6 c4 41	 test	 ah, 65			; 00000041H
  003ba	75 2e		 jne	 SHORT $L85022
  003bc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003bf	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  003c5	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  003cb	df e0		 fnstsw	 ax
  003cd	f6 c4 05	 test	 ah, 5
  003d0	7a 18		 jp	 SHORT $L85022
  003d2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003d5	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  003db	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  003e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  003e4	d9 99 78 06 00
	00		 fstp	 DWORD PTR [ecx+1656]
$L85022:

; 752  : 
; 753  : 		if( m_fMouseStickyX < 0 && bInGame )

  003ea	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  003ed	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  003f3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  003f9	df e0		 fnstsw	 ax
  003fb	f6 c4 05	 test	 ah, 5
  003fe	7a 52		 jp	 SHORT $L85023
  00400	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  00404	85 c0		 test	 eax, eax
  00406	74 4a		 je	 SHORT $L85023

; 754  : 		{
; 755  : 			m_FlightControls.fSteerLeft += fabsf( m_fMouseStickyX ) * fMouseSensitivity ;

  00408	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0040b	8b 88 74 06 00
	00		 mov	 ecx, DWORD PTR [eax+1652]
  00411	51		 push	 ecx
  00412	e8 00 00 00 00	 call	 _fabsf
  00417	83 c4 04	 add	 esp, 4
  0041a	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  0041d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00420	d8 82 b4 08 00
	00		 fadd	 DWORD PTR [edx+2228]
  00426	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00429	d9 98 b4 08 00
	00		 fstp	 DWORD PTR [eax+2228]

; 756  : 			if (m_FlightControls.fSteerLeft > MAX_FLIGHTMAP)

  0042f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00432	d9 80 b4 08 00
	00		 fld	 DWORD PTR [eax+2228]
  00438	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  0043e	df e0		 fnstsw	 ax
  00440	f6 c4 41	 test	 ah, 65			; 00000041H
  00443	75 0d		 jne	 SHORT $L85023

; 757  : 				m_FlightControls.fSteerLeft = MAX_FLIGHTMAP ;

  00445	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00448	c7 80 b4 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2228], 1101004800 ; 41a00000H
$L85023:

; 758  : 		}
; 759  : 		if( m_fMouseStickyX > 0 && bInGame )

  00452	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00455	d9 80 74 06 00
	00		 fld	 DWORD PTR [eax+1652]
  0045b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00461	df e0		 fnstsw	 ax
  00463	f6 c4 41	 test	 ah, 65			; 00000041H
  00466	75 52		 jne	 SHORT $L85025
  00468	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  0046c	85 c0		 test	 eax, eax
  0046e	74 4a		 je	 SHORT $L85025

; 760  : 		{
; 761  : 			m_FlightControls.fSteerRight += fabsf( m_fMouseStickyX ) * fMouseSensitivity ;

  00470	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00473	8b 88 74 06 00
	00		 mov	 ecx, DWORD PTR [eax+1652]
  00479	51		 push	 ecx
  0047a	e8 00 00 00 00	 call	 _fabsf
  0047f	83 c4 04	 add	 esp, 4
  00482	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  00485	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00488	d8 82 b8 08 00
	00		 fadd	 DWORD PTR [edx+2232]
  0048e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00491	d9 98 b8 08 00
	00		 fstp	 DWORD PTR [eax+2232]

; 762  : 			if (m_FlightControls.fSteerRight > MAX_FLIGHTMAP)

  00497	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0049a	d9 80 b8 08 00
	00		 fld	 DWORD PTR [eax+2232]
  004a0	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  004a6	df e0		 fnstsw	 ax
  004a8	f6 c4 41	 test	 ah, 65			; 00000041H
  004ab	75 0d		 jne	 SHORT $L85025

; 763  : 				m_FlightControls.fSteerRight = MAX_FLIGHTMAP ;

  004ad	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004b0	c7 80 b8 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2232], 1101004800 ; 41a00000H
$L85025:

; 764  : 		}
; 765  : 		if( m_fMouseStickyY < 0 && bInGame )

  004ba	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004bd	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  004c3	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  004c9	df e0		 fnstsw	 ax
  004cb	f6 c4 05	 test	 ah, 5
  004ce	7a 52		 jp	 SHORT $L85027
  004d0	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  004d4	85 c0		 test	 eax, eax
  004d6	74 4a		 je	 SHORT $L85027

; 766  : 		{
; 767  : 			m_FlightControls.fClimb += fabsf( m_fMouseStickyY ) * fMouseSensitivity ;

  004d8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004db	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  004e1	51		 push	 ecx
  004e2	e8 00 00 00 00	 call	 _fabsf
  004e7	83 c4 04	 add	 esp, 4
  004ea	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  004ed	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  004f0	d8 82 c0 08 00
	00		 fadd	 DWORD PTR [edx+2240]
  004f6	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004f9	d9 98 c0 08 00
	00		 fstp	 DWORD PTR [eax+2240]

; 768  : 			if (m_FlightControls.fClimb > MAX_FLIGHTMAP)

  004ff	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00502	d9 80 c0 08 00
	00		 fld	 DWORD PTR [eax+2240]
  00508	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  0050e	df e0		 fnstsw	 ax
  00510	f6 c4 41	 test	 ah, 65			; 00000041H
  00513	75 0d		 jne	 SHORT $L85027

; 769  : 				m_FlightControls.fClimb = MAX_FLIGHTMAP ;

  00515	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00518	c7 80 c0 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2240], 1101004800 ; 41a00000H
$L85027:

; 770  : 		}
; 771  : 		if( m_fMouseStickyY > 0 && bInGame )

  00522	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00525	d9 80 78 06 00
	00		 fld	 DWORD PTR [eax+1656]
  0052b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00531	df e0		 fnstsw	 ax
  00533	f6 c4 41	 test	 ah, 65			; 00000041H
  00536	75 52		 jne	 SHORT $L85029
  00538	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  0053c	85 c0		 test	 eax, eax
  0053e	74 4a		 je	 SHORT $L85029

; 772  : 		{
; 773  : 			m_FlightControls.fDive += fabsf( m_fMouseStickyY ) * fMouseSensitivity ;

  00540	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00543	8b 88 78 06 00
	00		 mov	 ecx, DWORD PTR [eax+1656]
  00549	51		 push	 ecx
  0054a	e8 00 00 00 00	 call	 _fabsf
  0054f	83 c4 04	 add	 esp, 4
  00552	d8 4d d0	 fmul	 DWORD PTR _fMouseSensitivity$[ebp]
  00555	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00558	d8 82 bc 08 00
	00		 fadd	 DWORD PTR [edx+2236]
  0055e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00561	d9 98 bc 08 00
	00		 fstp	 DWORD PTR [eax+2236]

; 774  : 			if (m_FlightControls.fDive > MAX_FLIGHTMAP)

  00567	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0056a	d9 80 bc 08 00
	00		 fld	 DWORD PTR [eax+2236]
  00570	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41a00000
  00576	df e0		 fnstsw	 ax
  00578	f6 c4 41	 test	 ah, 65			; 00000041H
  0057b	75 0d		 jne	 SHORT $L85029

; 775  : 				m_FlightControls.fDive = MAX_FLIGHTMAP ;

  0057d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00580	c7 80 bc 08 00
	00 00 00 a0 41	 mov	 DWORD PTR [eax+2236], 1101004800 ; 41a00000H
$L85029:

; 776  : 		}
; 777  : 
; 778  : 	//
; 779  : 	// Map Buttons:
; 780  : 	//
; 781  : 		m_bMouseLB = msMouse.rgbButtons[0] & 0x80 ;

  0058a	0f b6 45 e8	 movzx	 eax, BYTE PTR _msMouse$[ebp+12]
  0058e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00593	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00596	89 81 60 06 00
	00		 mov	 DWORD PTR [ecx+1632], eax

; 782  : 		m_bMouseRB = msMouse.rgbButtons[1] & 0x80 ;

  0059c	0f b6 45 e9	 movzx	 eax, BYTE PTR _msMouse$[ebp+13]
  005a0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005a5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005a8	89 81 68 06 00
	00		 mov	 DWORD PTR [ecx+1640], eax

; 783  : 		m_bMouseCB = msMouse.rgbButtons[2] & 0x80 ;

  005ae	0f b6 45 ea	 movzx	 eax, BYTE PTR _msMouse$[ebp+14]
  005b2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005b7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005ba	89 81 64 06 00
	00		 mov	 DWORD PTR [ecx+1636], eax

; 784  : 		
; 785  : 		if( m_bMouseLB && bInGame )

  005c0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005c3	83 b8 60 06 00
	00 00		 cmp	 DWORD PTR [eax+1632], 0
  005ca	74 15		 je	 SHORT $L85031
  005cc	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  005d0	85 c0		 test	 eax, eax
  005d2	74 0d		 je	 SHORT $L85031

; 786  : 			m_FlightControls.bFireA = TRUE ;

  005d4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005d7	c7 80 e0 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2272], 1
$L85031:

; 787  : 
; 788  : 		if( m_bMouseRB && bInGame )

  005e1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005e4	83 b8 68 06 00
	00 00		 cmp	 DWORD PTR [eax+1640], 0
  005eb	74 15		 je	 SHORT $L85032
  005ed	0f b6 45 08	 movzx	 eax, BYTE PTR _bInGame$[ebp]
  005f1	85 c0		 test	 eax, eax
  005f3	74 0d		 je	 SHORT $L85032

; 789  : 			m_FlightControls.bFireB = TRUE ;

  005f5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005f8	c7 80 e4 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2276], 1
$L85032:

; 790  : 
; 791  : 	//
; 792  : 	// Map any change in rollwheel:
; 793  : 	//
; 794  : 		//ods( "%0.1f %0.1f\n", m_fMouseZ, m_fMousePrevZ );
; 795  : 		m_bMouseWheelUp = m_bMouseWheelDown = false ;

  00602	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00605	c6 80 6d 06 00
	00 00		 mov	 BYTE PTR [eax+1645], 0
  0060c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0060f	c6 81 6c 06 00
	00 00		 mov	 BYTE PTR [ecx+1644], 0

; 796  : 		if( m_fMouseZ != m_fMousePrevZ && m_bScanForChangeInMouseWheel )

  00616	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00619	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0061c	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  00622	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  00628	df e0		 fnstsw	 ax
  0062a	f6 c4 44	 test	 ah, 68			; 00000044H
  0062d	7b 79		 jnp	 SHORT $L85033
  0062f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00632	83 b8 70 06 00
	00 00		 cmp	 DWORD PTR [eax+1648], 0
  00639	74 6d		 je	 SHORT $L85033

; 797  : 		{
; 798  : 			if( m_fMouseZ < m_fMousePrevZ )

  0063b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0063e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00641	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  00647	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  0064d	df e0		 fnstsw	 ax
  0064f	f6 c4 05	 test	 ah, 5
  00652	7a 17		 jp	 SHORT $L85034

; 799  : 			{
; 800  : 				m_FlightControls.bNextWeapon = TRUE ;

  00654	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00657	c7 80 d8 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2264], 1

; 801  : 				m_bMouseWheelDown = true ;

  00661	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00664	c6 80 6d 06 00
	00 01		 mov	 BYTE PTR [eax+1645], 1
$L85034:

; 802  : 			}
; 803  : 			if( m_fMouseZ > m_fMousePrevZ )

  0066b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0066e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00671	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  00677	d8 99 50 06 00
	00		 fcomp	 DWORD PTR [ecx+1616]
  0067d	df e0		 fnstsw	 ax
  0067f	f6 c4 41	 test	 ah, 65			; 00000041H
  00682	75 17		 jne	 SHORT $L85035

; 804  : 			{
; 805  : 				m_FlightControls.bPrevWeapon = TRUE ;

  00684	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00687	c7 80 dc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+2268], 1

; 806  : 				m_bMouseWheelUp = true ;

  00691	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00694	c6 80 6c 06 00
	00 01		 mov	 BYTE PTR [eax+1644], 1
$L85035:

; 807  : 			}
; 808  : 			
; 809  : 			m_bScanForChangeInMouseWheel = FALSE ;

  0069b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0069e	c7 80 70 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1648], 0
$L85033:

; 810  : 		}
; 811  : 		if( m_fMouseZ == 0 )

  006a8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  006ab	d9 80 5c 06 00
	00		 fld	 DWORD PTR [eax+1628]
  006b1	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  006b7	df e0		 fnstsw	 ax
  006b9	f6 c4 44	 test	 ah, 68			; 00000044H
  006bc	7a 0d		 jp	 SHORT $L85036

; 812  : 			m_bScanForChangeInMouseWheel = TRUE ;

  006be	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  006c1	c7 80 70 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1648], 1
$L85036:

; 813  : 		m_fMousePrevZ = m_fMouseZ ;

  006cb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  006ce	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  006d1	8b 91 5c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1628]
  006d7	89 90 50 06 00
	00		 mov	 DWORD PTR [eax+1616], edx

; 814  : 
; 815  : 		return S_OK ;

  006dd	33 c0		 xor	 eax, eax
$L84982:

; 816  : 	}

  006df	52		 push	 edx
  006e0	8b cd		 mov	 ecx, ebp
  006e2	50		 push	 eax
  006e3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L85164
  006e9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006ee	58		 pop	 eax
  006ef	5a		 pop	 edx
  006f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f3	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  006f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006fb	5f		 pop	 edi
  006fc	5e		 pop	 esi
  006fd	5b		 pop	 ebx
  006fe	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00704	3b ec		 cmp	 ebp, esp
  00706	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0070b	8b e5		 mov	 esp, ebp
  0070d	5d		 pop	 ebp
  0070e	c2 04 00	 ret	 4
$L85164:
  00711	02 00 00 00	 DD	 2
  00715	00 00 00 00	 DD	 $L85163
$L85163:
  00719	dc ff ff ff	 DD	 -36			; ffffffdcH
  0071d	10 00 00 00	 DD	 16			; 00000010H
  00721	00 00 00 00	 DD	 $L85160
  00725	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00729	0c 00 00 00	 DD	 12			; 0000000cH
  0072d	00 00 00 00	 DD	 $L85161
$L85161:
  00731	76		 DB	 118			; 00000076H
  00732	41		 DB	 65			; 00000041H
  00733	00		 DB	 0
$L85160:
  00734	6d		 DB	 109			; 0000006dH
  00735	73		 DB	 115			; 00000073H
  00736	4d		 DB	 77			; 0000004dH
  00737	6f		 DB	 111			; 0000006fH
  00738	75		 DB	 117			; 00000075H
  00739	73		 DB	 115			; 00000073H
  0073a	65		 DB	 101			; 00000065H
  0073b	00		 DB	 0
?PollMouseSticky@CUserInput@@QAEJ_N@Z ENDP		; CUserInput::PollMouseSticky
; Function compile flags: /Odt /RTCsu /ZI
; File c:\dxsdk\include\d3dx8math.inl
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -8
_fx$ = 8
_fy$ = 12
_fz$ = 16
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 180  :     x = fx;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 181  :     y = fy;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 182  :     z = fz;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  0003a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 183  : }

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Odt /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8
_v$ = 8
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 204  :     x += v.x;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00029	d9 00		 fld	 DWORD PTR [eax]
  0002b	d8 01		 fadd	 DWORD PTR [ecx]
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	d9 1a		 fstp	 DWORD PTR [edx]

; 205  :     y += v.y;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00038	d9 40 04	 fld	 DWORD PTR [eax+4]
  0003b	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 206  :     z += v.z;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0004a	d9 40 08	 fld	 DWORD PTR [eax+8]
  0004d	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 207  :     return *this;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 208  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
; Function compile flags: /Odt /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_fInv$ = -20
_this$ = -8
_f$ = 8
??_0D3DXVECTOR3@@QAEAAU0@M@Z PROC NEAR			; D3DXVECTOR3::operator/=, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :     FLOAT fInv = 1.0f / f;

  00023	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00029	d8 75 08	 fdiv	 DWORD PTR _f$[ebp]
  0002c	d9 5d ec	 fstp	 DWORD PTR _fInv$[ebp]

; 232  :     x *= fInv;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  00035	d8 08		 fmul	 DWORD PTR [eax]
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	d9 19		 fstp	 DWORD PTR [ecx]

; 233  :     y *= fInv;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  00042	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 234  :     z *= fInv;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	d9 45 ec	 fld	 DWORD PTR _fInv$[ebp]
  00051	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 235  :     return *this;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 236  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??_0D3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator/=
; Function compile flags: /Odt /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
_this$ = -8
___$ReturnUdt$ = 8
_f$ = 12
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC NEAR			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	d9 45 0c	 fld	 DWORD PTR _f$[ebp]
  00029	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0002c	51		 push	 ecx
  0002d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	d9 45 0c	 fld	 DWORD PTR _f$[ebp]
  00036	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00039	51		 push	 ecx
  0003a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0003d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00040	d9 45 0c	 fld	 DWORD PTR _f$[ebp]
  00043	d8 0a		 fmul	 DWORD PTR [edx]
  00045	51		 push	 ecx
  00046	d9 1c 24	 fstp	 DWORD PTR [esp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	e8 00 00 00 00	 call	 ??0D3DXVECTOR3@@QAE@MMM@Z ; D3DXVECTOR3::D3DXVECTOR3
  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 270  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
END
