; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	D3DFrame8.1 Custom\src\dxutil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JADGJGAE@?2Media?2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_GetDXSDKMediaPath@@YAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_FindMediaFile@@YAJPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertGenericStringToWide@@YAXPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertWideStringToGeneric@@YAXPADPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_DbgOut@@YAJPADKJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_Trace@@YAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fLastElapsedTime
?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fBaseTime
?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fStopTime
?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 02H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strNull
	ALIGN	4

?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bTimerInitialized
?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bUsingQPF
	ALIGN	8

?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`2'::m_llQPFTicksPerSec
?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llStopTime
?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llLastElapsedTime
?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llBaseTime
_BSS	ENDS
_DATA	SEGMENT
?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H ; `DXUtil_Timer'::`2'::m_bTimerStopped
_DATA	ENDS
PUBLIC	?DXUtil_GetDXSDKMediaPath@@YAPBDXZ		; DXUtil_GetDXSDKMediaPath
PUBLIC	??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ ; `string'
PUBLIC	??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@	; `string'
PUBLIC	??_C@_07JADGJGAE@?2Media?2?$AA@			; `string'
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	_strcat:NEAR
_BSS	SEGMENT
?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 0104H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strPath
_BSS	ENDS
;	COMDAT rtc$IMZ
; File c:\documents and settings\dom\my documents\_dev\ae\xlr8a\x7g\d3dframe8.1 custom\src\dxutil.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
CONST	SEGMENT
??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ DB 'Software\Mi'
	DB	'crosoft\DirectX SDK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
CONST	SEGMENT
??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@ DB 'DX81SDK Samples Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JADGJGAE@?2Media?2?$AA@
CONST	SEGMENT
??_C@_07JADGJGAE@?2Media?2?$AA@ DB '\Media\', 00H	; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_GetDXSDKMediaPath@@YAPBDXZ
_TEXT	SEGMENT
_lResult$ = -44
_hKey$ = -32
_dwSize$ = -20
_dwType$ = -8
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ PROC NEAR		; DXUtil_GetDXSDKMediaPath, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 26   :     static TCHAR strNull[2] = _T("");
; 27   :     static TCHAR strPath[MAX_PATH];
; 28   :     DWORD dwType;
; 29   :     DWORD dwSize = MAX_PATH;

  0001e	c7 45 ec 04 01
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 260 ; 00000104H

; 30   :     HKEY  hKey;
; 31   : 
; 32   :     // Open the appropriate registry key
; 33   :     LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 34   :                                 _T("Software\\Microsoft\\DirectX SDK"),
; 35   :                                 0, KEY_READ, &hKey );

  00025	8b f4		 mov	 esi, esp
  00027	8d 45 e0	 lea	 eax, DWORD PTR _hKey$[ebp]
  0002a	50		 push	 eax
  0002b	68 19 00 02 00	 push	 131097			; 00020019H
  00030	6a 00		 push	 0
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
  00037	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d4	 mov	 DWORD PTR _lResult$[ebp], eax

; 36   :     if( ERROR_SUCCESS != lResult )

  0004c	83 7d d4 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  00050	74 07		 je	 SHORT $L72537

; 37   :         return strNull;

  00052	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
  00057	eb 61		 jmp	 SHORT $L72524
$L72537:

; 38   : 
; 39   :     lResult = RegQueryValueEx( hKey, _T("DX81SDK Samples Path"), NULL,
; 40   :                               &dwType, (BYTE*)strPath, &dwSize );

  00059	8b f4		 mov	 esi, esp
  0005b	8d 45 ec	 lea	 eax, DWORD PTR _dwSize$[ebp]
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
  00064	8d 4d f8	 lea	 ecx, DWORD PTR _dwType$[ebp]
  00067	51		 push	 ecx
  00068	6a 00		 push	 0
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
  0006f	8b 55 e0	 mov	 edx, DWORD PTR _hKey$[ebp]
  00072	52		 push	 edx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	89 45 d4	 mov	 DWORD PTR _lResult$[ebp], eax

; 41   :     RegCloseKey( hKey );

  00083	8b f4		 mov	 esi, esp
  00085	8b 45 e0	 mov	 eax, DWORD PTR _hKey$[ebp]
  00088	50		 push	 eax
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 42   : 
; 43   :     if( ERROR_SUCCESS != lResult )

  00096	83 7d d4 00	 cmp	 DWORD PTR _lResult$[ebp], 0
  0009a	74 07		 je	 SHORT $L72540

; 44   :         return strNull;

  0009c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
  000a1	eb 17		 jmp	 SHORT $L72524
$L72540:

; 45   : 
; 46   :     _tcscat( strPath, _T("\\Media\\") );

  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JADGJGAE@?2Media?2?$AA@
  000a8	68 00 00 00 00	 push	 OFFSET FLAT:?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
  000ad	e8 00 00 00 00	 call	 _strcat
  000b2	83 c4 08	 add	 esp, 8

; 47   : 
; 48   :     return strPath;

  000b5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
$L72524:

; 49   : }

  000ba	52		 push	 edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	50		 push	 eax
  000be	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72882
  000c4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c9	58		 pop	 eax
  000ca	5a		 pop	 edx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
$L72882:
  000df	03 00 00 00	 DD	 3
  000e3	00 00 00 00	 DD	 $L72881
$L72881:
  000e7	f8 ff ff ff	 DD	 -8			; fffffff8H
  000eb	04 00 00 00	 DD	 4
  000ef	00 00 00 00	 DD	 $L72878
  000f3	ec ff ff ff	 DD	 -20			; ffffffecH
  000f7	04 00 00 00	 DD	 4
  000fb	00 00 00 00	 DD	 $L72879
  000ff	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00103	04 00 00 00	 DD	 4
  00107	00 00 00 00	 DD	 $L72880
$L72880:
  0010b	68		 DB	 104			; 00000068H
  0010c	4b		 DB	 75			; 0000004bH
  0010d	65		 DB	 101			; 00000065H
  0010e	79		 DB	 121			; 00000079H
  0010f	00		 DB	 0
$L72879:
  00110	64		 DB	 100			; 00000064H
  00111	77		 DB	 119			; 00000077H
  00112	53		 DB	 83			; 00000053H
  00113	69		 DB	 105			; 00000069H
  00114	7a		 DB	 122			; 0000007aH
  00115	65		 DB	 101			; 00000065H
  00116	00		 DB	 0
$L72878:
  00117	64		 DB	 100			; 00000064H
  00118	77		 DB	 119			; 00000077H
  00119	54		 DB	 84			; 00000054H
  0011a	79		 DB	 121			; 00000079H
  0011b	70		 DB	 112			; 00000070H
  0011c	65		 DB	 101			; 00000065H
  0011d	00		 DB	 0
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ ENDP			; DXUtil_GetDXSDKMediaPath
_TEXT	ENDS
PUBLIC	?DXUtil_FindMediaFile@@YAJPAD0@Z		; DXUtil_FindMediaFile
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp__GetFullPathNameA@16:NEAR
EXTRN	__imp__CreateFileA@28:NEAR
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_FindMediaFile@@YAJPAD0@Z
_TEXT	SEGMENT
_cchPath$ = -1072
_strShortName$ = -1060
_strFullPath$ = -1048
_file$ = -12
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_strPath$ = 8
_strFilename$ = 12
?DXUtil_FindMediaFile@@YAJPAD0@Z PROC NEAR		; DXUtil_FindMediaFile, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 04 00
	00		 sub	 esp, 1268		; 000004f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1268]
  00012	b9 3d 01 00 00	 mov	 ecx, 317		; 0000013dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 60   :     HANDLE file;
; 61   :     TCHAR strFullPath[1024];
; 62   :     TCHAR *strShortName;
; 63   :     DWORD cchPath;
; 64   : 
; 65   :     if( NULL==strFilename || NULL==strPath )

  00029	83 7d 0c 00	 cmp	 DWORD PTR _strFilename$[ebp], 0
  0002d	74 06		 je	 SHORT $L72551
  0002f	83 7d 08 00	 cmp	 DWORD PTR _strPath$[ebp], 0
  00033	75 0a		 jne	 SHORT $L72550
$L72551:

; 66   :         return E_INVALIDARG;

  00035	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0003a	e9 73 01 00 00	 jmp	 $L72545
$L72550:

; 67   : 
; 68   :     // Build full path name from strFileName (strShortName will be just the leaf filename)
; 69   :     cchPath = GetFullPathName(strFilename, sizeof(strFullPath)/sizeof(TCHAR), strFullPath, &strShortName);

  0003f	8b f4		 mov	 esi, esp
  00041	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR _strShortName$[ebp]
  00047	50		 push	 eax
  00048	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _strFullPath$[ebp]
  0004e	51		 push	 ecx
  0004f	68 00 04 00 00	 push	 1024			; 00000400H
  00054	8b 55 0c	 mov	 edx, DWORD PTR _strFilename$[ebp]
  00057	52		 push	 edx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFullPathNameA@16
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	89 85 d0 fb ff
	ff		 mov	 DWORD PTR _cchPath$[ebp], eax

; 70   :     if ((cchPath == 0) || (sizeof(strFullPath)/sizeof(TCHAR) <= cchPath))

  0006b	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _cchPath$[ebp], 0
  00072	74 0c		 je	 SHORT $L72556
  00074	81 bd d0 fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR _cchPath$[ebp], 1024 ; 00000400H
  0007e	72 0a		 jb	 SHORT $L72555
$L72556:

; 71   :         return E_FAIL;

  00080	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00085	e9 28 01 00 00	 jmp	 $L72545
$L72555:

; 72   : 
; 73   :     // first try to find the filename given a full path
; 74   :     file = CreateFile( strFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 75   :                        OPEN_EXISTING, 0, NULL );

  0008a	8b f4		 mov	 esi, esp
  0008c	6a 00		 push	 0
  0008e	6a 00		 push	 0
  00090	6a 03		 push	 3
  00092	6a 00		 push	 0
  00094	6a 01		 push	 1
  00096	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0009b	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _strFullPath$[ebp]
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	89 45 f4	 mov	 DWORD PTR _file$[ebp], eax

; 76   :     if( INVALID_HANDLE_VALUE != file )

  000b2	83 7d f4 ff	 cmp	 DWORD PTR _file$[ebp], -1
  000b6	74 2d		 je	 SHORT $L72560

; 77   :     {
; 78   :         _tcscpy( strPath, strFullPath );

  000b8	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _strFullPath$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _strPath$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _strcpy
  000c8	83 c4 08	 add	 esp, 8

; 79   :         CloseHandle( file );

  000cb	8b f4		 mov	 esi, esp
  000cd	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  000d0	50		 push	 eax
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 80   :         return S_OK;

  000de	33 c0		 xor	 eax, eax
  000e0	e9 cd 00 00 00	 jmp	 $L72545
$L72560:

; 81   :     }
; 82   :     
; 83   :     // next try to find the filename in the current working directory (path stripped)
; 84   :     file = CreateFile( strShortName, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 85   :                        OPEN_EXISTING, 0, NULL );

  000e5	8b f4		 mov	 esi, esp
  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	6a 03		 push	 3
  000ed	6a 00		 push	 0
  000ef	6a 01		 push	 1
  000f1	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000f6	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _strShortName$[ebp]
  000fc	50		 push	 eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00103	3b f4		 cmp	 esi, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	89 45 f4	 mov	 DWORD PTR _file$[ebp], eax

; 86   :     if( INVALID_HANDLE_VALUE != file )

  0010d	83 7d f4 ff	 cmp	 DWORD PTR _file$[ebp], -1
  00111	74 2a		 je	 SHORT $L72564

; 87   :     {
; 88   :         _tcscpy( strPath, strShortName );

  00113	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _strShortName$[ebp]
  00119	50		 push	 eax
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _strPath$[ebp]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 _strcpy
  00123	83 c4 08	 add	 esp, 8

; 89   :         CloseHandle( file );

  00126	8b f4		 mov	 esi, esp
  00128	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  0012b	50		 push	 eax
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00132	3b f4		 cmp	 esi, esp
  00134	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   :         return S_OK;

  00139	33 c0		 xor	 eax, eax
  0013b	eb 75		 jmp	 SHORT $L72545
$L72564:

; 91   :     }
; 92   :     
; 93   :     // last, check if the file exists in the media directory
; 94   :     _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strShortName );

  0013d	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _strShortName$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?DXUtil_GetDXSDKMediaPath@@YAPBDXZ ; DXUtil_GetDXSDKMediaPath
  00149	50		 push	 eax
  0014a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _strPath$[ebp]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _sprintf
  00158	83 c4 10	 add	 esp, 16			; 00000010H

; 95   : 
; 96   :     file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 97   :                        OPEN_EXISTING, 0, NULL );

  0015b	8b f4		 mov	 esi, esp
  0015d	6a 00		 push	 0
  0015f	6a 00		 push	 0
  00161	6a 03		 push	 3
  00163	6a 00		 push	 0
  00165	6a 01		 push	 1
  00167	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0016c	8b 45 08	 mov	 eax, DWORD PTR _strPath$[ebp]
  0016f	50		 push	 eax
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00176	3b f4		 cmp	 esi, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	89 45 f4	 mov	 DWORD PTR _file$[ebp], eax

; 98   :     if( INVALID_HANDLE_VALUE != file )

  00180	83 7d f4 ff	 cmp	 DWORD PTR _file$[ebp], -1
  00184	74 17		 je	 SHORT $L72569

; 99   :     {
; 100  :         CloseHandle( file );

  00186	8b f4		 mov	 esi, esp
  00188	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  0018b	50		 push	 eax
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00192	3b f4		 cmp	 esi, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 101  :         return S_OK;

  00199	33 c0		 xor	 eax, eax
  0019b	eb 15		 jmp	 SHORT $L72545
$L72569:

; 102  :     }
; 103  : 
; 104  :     // On failure, just return the file as the path
; 105  :     _tcscpy( strPath, strFilename );

  0019d	8b 45 0c	 mov	 eax, DWORD PTR _strFilename$[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _strPath$[ebp]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 _strcpy
  001aa	83 c4 08	 add	 esp, 8

; 106  :     return E_FAIL;

  001ad	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L72545:

; 107  : }

  001b2	52		 push	 edx
  001b3	8b cd		 mov	 ecx, ebp
  001b5	50		 push	 eax
  001b6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72894
  001bc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001c1	58		 pop	 eax
  001c2	5a		 pop	 edx
  001c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c6	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  001c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
  001d0	5b		 pop	 ebx
  001d1	81 c4 f4 04 00
	00		 add	 esp, 1268		; 000004f4H
  001d7	3b ec		 cmp	 ebp, esp
  001d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c3		 ret	 0
$L72894:
  001e2	02 00 00 00	 DD	 2
  001e6	00 00 00 00	 DD	 $L72893
$L72893:
  001ea	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  001ee	00 04 00 00	 DD	 1024			; 00000400H
  001f2	00 00 00 00	 DD	 $L72889
  001f6	dc fb ff ff	 DD	 -1060			; fffffbdcH
  001fa	04 00 00 00	 DD	 4
  001fe	00 00 00 00	 DD	 $L72890
$L72890:
  00202	73		 DB	 115			; 00000073H
  00203	74		 DB	 116			; 00000074H
  00204	72		 DB	 114			; 00000072H
  00205	53		 DB	 83			; 00000053H
  00206	68		 DB	 104			; 00000068H
  00207	6f		 DB	 111			; 0000006fH
  00208	72		 DB	 114			; 00000072H
  00209	74		 DB	 116			; 00000074H
  0020a	4e		 DB	 78			; 0000004eH
  0020b	61		 DB	 97			; 00000061H
  0020c	6d		 DB	 109			; 0000006dH
  0020d	65		 DB	 101			; 00000065H
  0020e	00		 DB	 0
$L72889:
  0020f	73		 DB	 115			; 00000073H
  00210	74		 DB	 116			; 00000074H
  00211	72		 DB	 114			; 00000072H
  00212	46		 DB	 70			; 00000046H
  00213	75		 DB	 117			; 00000075H
  00214	6c		 DB	 108			; 0000006cH
  00215	6c		 DB	 108			; 0000006cH
  00216	50		 DB	 80			; 00000050H
  00217	61		 DB	 97			; 00000061H
  00218	74		 DB	 116			; 00000074H
  00219	68		 DB	 104			; 00000068H
  0021a	00		 DB	 0
?DXUtil_FindMediaFile@@YAJPAD0@Z ENDP			; DXUtil_FindMediaFile
_TEXT	ENDS
PUBLIC	?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ; DXUtil_ReadStringRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z
_TEXT	SEGMENT
_dwType$ = -8
_hKey$ = 8
_strRegName$ = 12
_strValue$ = 16
_dwLength$ = 20
_strDefault$ = 24
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z PROC NEAR ; DXUtil_ReadStringRegKey, COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 119  :     DWORD dwType;
; 120  : 
; 121  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 122  :                                           (BYTE*)strValue, &dwLength ) )

  0001e	8b f4		 mov	 esi, esp
  00020	8d 45 14	 lea	 eax, DWORD PTR _dwLength$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR _strValue$[ebp]
  00027	51		 push	 ecx
  00028	8d 55 f8	 lea	 edx, DWORD PTR _dwType$[ebp]
  0002b	52		 push	 edx
  0002c	6a 00		 push	 0
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _strRegName$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	85 c0		 test	 eax, eax
  00045	74 10		 je	 SHORT $L72581

; 123  :     {
; 124  :         _tcscpy( strValue, strDefault );

  00047	8b 45 18	 mov	 eax, DWORD PTR _strDefault$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _strValue$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _strcpy
  00054	83 c4 08	 add	 esp, 8
$L72581:

; 125  :     }
; 126  : 
; 127  :     return S_OK;

  00057	33 c0		 xor	 eax, eax

; 128  : }

  00059	52		 push	 edx
  0005a	8b cd		 mov	 ecx, ebp
  0005c	50		 push	 eax
  0005d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72900
  00063	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00068	58		 pop	 eax
  00069	5a		 pop	 edx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$L72900:
  0007e	01 00 00 00	 DD	 1
  00082	00 00 00 00	 DD	 $L72899
$L72899:
  00086	f8 ff ff ff	 DD	 -8			; fffffff8H
  0008a	04 00 00 00	 DD	 4
  0008e	00 00 00 00	 DD	 $L72898
$L72898:
  00092	64		 DB	 100			; 00000064H
  00093	77		 DB	 119			; 00000077H
  00094	54		 DB	 84			; 00000054H
  00095	79		 DB	 121			; 00000079H
  00096	70		 DB	 112			; 00000070H
  00097	65		 DB	 101			; 00000065H
  00098	00		 DB	 0
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ENDP	; DXUtil_ReadStringRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z	; DXUtil_WriteStringRegKey
EXTRN	__imp__RegSetValueExA@24:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z
_TEXT	SEGMENT
_hKey$ = 8
_strRegName$ = 12
_strValue$ = 16
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z PROC NEAR ; DXUtil_WriteStringRegKey, COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 140  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
; 141  :                                         (BYTE*)strValue, 
; 142  :                                         (_tcslen(strValue)+1)*sizeof(TCHAR) ) )

  0001e	8b 45 10	 mov	 eax, DWORD PTR _strValue$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	83 c0 01	 add	 eax, 1
  0002d	8b f4		 mov	 esi, esp
  0002f	50		 push	 eax
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _strValue$[ebp]
  00033	51		 push	 ecx
  00034	6a 01		 push	 1
  00036	6a 00		 push	 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _strRegName$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _hKey$[ebp]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	85 c0		 test	 eax, eax
  0004f	74 07		 je	 SHORT $L72590

; 143  :         return E_FAIL;

  00051	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00056	eb 02		 jmp	 SHORT $L72587
$L72590:

; 144  : 
; 145  :     return S_OK;

  00058	33 c0		 xor	 eax, eax
$L72587:

; 146  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z ENDP	; DXUtil_WriteStringRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z	; DXUtil_ReadIntRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z
_TEXT	SEGMENT
_dwLength$ = -20
_dwType$ = -8
_hKey$ = 8
_strRegName$ = 12
_pdwValue$ = 16
_dwDefault$ = 20
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z PROC NEAR ; DXUtil_ReadIntRegKey, COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 158  :     DWORD dwType;
; 159  :     DWORD dwLength = sizeof(DWORD);

  0001e	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _dwLength$[ebp], 4

; 160  : 
; 161  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 162  :                                           (BYTE*)pdwValue, &dwLength ) )

  00025	8b f4		 mov	 esi, esp
  00027	8d 45 ec	 lea	 eax, DWORD PTR _dwLength$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _pdwValue$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _dwType$[ebp]
  00032	52		 push	 edx
  00033	6a 00		 push	 0
  00035	8b 45 0c	 mov	 eax, DWORD PTR _strRegName$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	85 c0		 test	 eax, eax
  0004c	74 08		 je	 SHORT $L72603

; 163  :     {
; 164  :         *pdwValue = dwDefault;

  0004e	8b 45 10	 mov	 eax, DWORD PTR _pdwValue$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _dwDefault$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
$L72603:

; 165  :     }
; 166  : 
; 167  :     return S_OK;

  00056	33 c0		 xor	 eax, eax

; 168  : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72908
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$L72908:
  0007d	02 00 00 00	 DD	 2
  00081	00 00 00 00	 DD	 $L72907
$L72907:
  00085	f8 ff ff ff	 DD	 -8			; fffffff8H
  00089	04 00 00 00	 DD	 4
  0008d	00 00 00 00	 DD	 $L72905
  00091	ec ff ff ff	 DD	 -20			; ffffffecH
  00095	04 00 00 00	 DD	 4
  00099	00 00 00 00	 DD	 $L72906
$L72906:
  0009d	64		 DB	 100			; 00000064H
  0009e	77		 DB	 119			; 00000077H
  0009f	4c		 DB	 76			; 0000004cH
  000a0	65		 DB	 101			; 00000065H
  000a1	6e		 DB	 110			; 0000006eH
  000a2	67		 DB	 103			; 00000067H
  000a3	74		 DB	 116			; 00000074H
  000a4	68		 DB	 104			; 00000068H
  000a5	00		 DB	 0
$L72905:
  000a6	64		 DB	 100			; 00000064H
  000a7	77		 DB	 119			; 00000077H
  000a8	54		 DB	 84			; 00000054H
  000a9	79		 DB	 121			; 00000079H
  000aa	70		 DB	 112			; 00000070H
  000ab	65		 DB	 101			; 00000065H
  000ac	00		 DB	 0
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z ENDP	; DXUtil_ReadIntRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z	; DXUtil_WriteIntRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z
_TEXT	SEGMENT
_hKey$ = 8
_strRegName$ = 12
_dwValue$ = 16
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z PROC NEAR	; DXUtil_WriteIntRegKey, COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 179  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 180  :                                         (BYTE*)&dwValue, sizeof(DWORD) ) )

  0001e	8b f4		 mov	 esi, esp
  00020	6a 04		 push	 4
  00022	8d 45 10	 lea	 eax, DWORD PTR _dwValue$[ebp]
  00025	50		 push	 eax
  00026	6a 04		 push	 4
  00028	6a 00		 push	 0
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegName$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _hKey$[ebp]
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	85 c0		 test	 eax, eax
  00041	74 07		 je	 SHORT $L72612

; 181  :         return E_FAIL;

  00043	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00048	eb 02		 jmp	 SHORT $L72609
$L72612:

; 182  : 
; 183  :     return S_OK;

  0004a	33 c0		 xor	 eax, eax
$L72609:

; 184  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z ENDP	; DXUtil_WriteIntRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z	; DXUtil_ReadBoolRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z
_TEXT	SEGMENT
_dwLength$ = -20
_dwType$ = -8
_hKey$ = 8
_strRegName$ = 12
_pbValue$ = 16
_bDefault$ = 20
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z PROC NEAR ; DXUtil_ReadBoolRegKey, COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 196  :     DWORD dwType;
; 197  :     DWORD dwLength = sizeof(BOOL);

  0001e	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _dwLength$[ebp], 4

; 198  : 
; 199  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 200  :                                           (BYTE*)pbValue, &dwLength ) )

  00025	8b f4		 mov	 esi, esp
  00027	8d 45 ec	 lea	 eax, DWORD PTR _dwLength$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _pbValue$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _dwType$[ebp]
  00032	52		 push	 edx
  00033	6a 00		 push	 0
  00035	8b 45 0c	 mov	 eax, DWORD PTR _strRegName$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	85 c0		 test	 eax, eax
  0004c	74 08		 je	 SHORT $L72625

; 201  :     {
; 202  :         *pbValue = bDefault;

  0004e	8b 45 10	 mov	 eax, DWORD PTR _pbValue$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _bDefault$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
$L72625:

; 203  :     }
; 204  : 
; 205  :     return S_OK;

  00056	33 c0		 xor	 eax, eax

; 206  : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72916
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$L72916:
  0007d	02 00 00 00	 DD	 2
  00081	00 00 00 00	 DD	 $L72915
$L72915:
  00085	f8 ff ff ff	 DD	 -8			; fffffff8H
  00089	04 00 00 00	 DD	 4
  0008d	00 00 00 00	 DD	 $L72913
  00091	ec ff ff ff	 DD	 -20			; ffffffecH
  00095	04 00 00 00	 DD	 4
  00099	00 00 00 00	 DD	 $L72914
$L72914:
  0009d	64		 DB	 100			; 00000064H
  0009e	77		 DB	 119			; 00000077H
  0009f	4c		 DB	 76			; 0000004cH
  000a0	65		 DB	 101			; 00000065H
  000a1	6e		 DB	 110			; 0000006eH
  000a2	67		 DB	 103			; 00000067H
  000a3	74		 DB	 116			; 00000074H
  000a4	68		 DB	 104			; 00000068H
  000a5	00		 DB	 0
$L72913:
  000a6	64		 DB	 100			; 00000064H
  000a7	77		 DB	 119			; 00000077H
  000a8	54		 DB	 84			; 00000054H
  000a9	79		 DB	 121			; 00000079H
  000aa	70		 DB	 112			; 00000070H
  000ab	65		 DB	 101			; 00000065H
  000ac	00		 DB	 0
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z ENDP	; DXUtil_ReadBoolRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z	; DXUtil_WriteBoolRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z
_TEXT	SEGMENT
_hKey$ = 8
_strRegName$ = 12
_bValue$ = 16
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z PROC NEAR	; DXUtil_WriteBoolRegKey, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 217  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 218  :                                         (BYTE*)&bValue, sizeof(BOOL) ) )

  0001e	8b f4		 mov	 esi, esp
  00020	6a 04		 push	 4
  00022	8d 45 10	 lea	 eax, DWORD PTR _bValue$[ebp]
  00025	50		 push	 eax
  00026	6a 04		 push	 4
  00028	6a 00		 push	 0
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegName$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _hKey$[ebp]
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	85 c0		 test	 eax, eax
  00041	74 07		 je	 SHORT $L72634

; 219  :         return E_FAIL;

  00043	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00048	eb 02		 jmp	 SHORT $L72631
$L72634:

; 220  : 
; 221  :     return S_OK;

  0004a	33 c0		 xor	 eax, eax
$L72631:

; 222  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z ENDP	; DXUtil_WriteBoolRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ; DXUtil_ReadGuidRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z
_TEXT	SEGMENT
_dwLength$ = -20
_dwType$ = -8
_hKey$ = 8
_strRegName$ = 12
_pGuidValue$ = 16
_guidDefault$ = 20
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z PROC NEAR ; DXUtil_ReadGuidRegKey, COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 234  :     DWORD dwType;
; 235  :     DWORD dwLength = sizeof(GUID);

  0001e	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _dwLength$[ebp], 16 ; 00000010H

; 236  : 
; 237  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 238  :                                           (LPBYTE) pGuidValue, &dwLength ) )

  00025	8b f4		 mov	 esi, esp
  00027	8d 45 ec	 lea	 eax, DWORD PTR _dwLength$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _pGuidValue$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _dwType$[ebp]
  00032	52		 push	 edx
  00033	6a 00		 push	 0
  00035	8b 45 0c	 mov	 eax, DWORD PTR _strRegName$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	85 c0		 test	 eax, eax
  0004c	74 1c		 je	 SHORT $L72647

; 239  :     {
; 240  :         *pGuidValue = guidDefault;

  0004e	8b 45 14	 mov	 eax, DWORD PTR _guidDefault$[ebp]
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _pGuidValue$[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	89 11		 mov	 DWORD PTR [ecx], edx
  00058	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0005e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00061	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00064	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00067	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L72647:

; 241  :     }
; 242  : 
; 243  :     return S_OK;

  0006a	33 c0		 xor	 eax, eax

; 244  : }

  0006c	52		 push	 edx
  0006d	8b cd		 mov	 ecx, ebp
  0006f	50		 push	 eax
  00070	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72924
  00076	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007b	58		 pop	 eax
  0007c	5a		 pop	 edx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$L72924:
  00091	02 00 00 00	 DD	 2
  00095	00 00 00 00	 DD	 $L72923
$L72923:
  00099	f8 ff ff ff	 DD	 -8			; fffffff8H
  0009d	04 00 00 00	 DD	 4
  000a1	00 00 00 00	 DD	 $L72921
  000a5	ec ff ff ff	 DD	 -20			; ffffffecH
  000a9	04 00 00 00	 DD	 4
  000ad	00 00 00 00	 DD	 $L72922
$L72922:
  000b1	64		 DB	 100			; 00000064H
  000b2	77		 DB	 119			; 00000077H
  000b3	4c		 DB	 76			; 0000004cH
  000b4	65		 DB	 101			; 00000065H
  000b5	6e		 DB	 110			; 0000006eH
  000b6	67		 DB	 103			; 00000067H
  000b7	74		 DB	 116			; 00000074H
  000b8	68		 DB	 104			; 00000068H
  000b9	00		 DB	 0
$L72921:
  000ba	64		 DB	 100			; 00000064H
  000bb	77		 DB	 119			; 00000077H
  000bc	54		 DB	 84			; 00000054H
  000bd	79		 DB	 121			; 00000079H
  000be	70		 DB	 112			; 00000070H
  000bf	65		 DB	 101			; 00000065H
  000c0	00		 DB	 0
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ENDP ; DXUtil_ReadGuidRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ; DXUtil_WriteGuidRegKey
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z
_TEXT	SEGMENT
_hKey$ = 8
_strRegName$ = 12
_guidValue$ = 16
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z PROC NEAR ; DXUtil_WriteGuidRegKey, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 255  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
; 256  :                                         (BYTE*)&guidValue, sizeof(GUID) ) )

  0001e	8b f4		 mov	 esi, esp
  00020	6a 10		 push	 16			; 00000010H
  00022	8d 45 10	 lea	 eax, DWORD PTR _guidValue$[ebp]
  00025	50		 push	 eax
  00026	6a 03		 push	 3
  00028	6a 00		 push	 0
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegName$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _hKey$[ebp]
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	85 c0		 test	 eax, eax
  00041	74 07		 je	 SHORT $L72656

; 257  :         return E_FAIL;

  00043	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00048	eb 02		 jmp	 SHORT $L72653
$L72656:

; 258  : 
; 259  :     return S_OK;

  0004a	33 c0		 xor	 eax, eax
$L72653:

; 260  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ENDP ; DXUtil_WriteGuidRegKey
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3fb99999a0000000
PUBLIC	?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z		; DXUtil_Timer
EXTRN	__alldiv:NEAR
EXTRN	__fltused:NEAR
EXTRN	__imp__timeGetTime@0:NEAR
EXTRN	__imp__QueryPerformanceCounter@4:NEAR
EXTRN	__imp__QueryPerformanceFrequency@4:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z
_TEXT	SEGMENT
tv240 = -316
tv186 = -316
tv174 = -316
tv263 = -312
tv249 = -312
tv247 = -312
tv230 = -312
tv190 = -312
tv180 = -312
_fElapsedTime$72710 = -112
_fTime$72709 = -96
_fAppTime$72690 = -80
_qwTime$72682 = -64
_fElapsedTime$72681 = -48
_fTime$72680 = -32
_qwTicksPerSec$72671 = -16
_command$ = 8
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z PROC NEAR		; DXUtil_Timer, COMDAT

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00012	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 279  :     static BOOL     m_bTimerInitialized = FALSE;
; 280  :     static BOOL     m_bUsingQPF         = FALSE;
; 281  :     static BOOL     m_bTimerStopped     = TRUE;
; 282  :     static LONGLONG m_llQPFTicksPerSec  = 0;
; 283  : 
; 284  :     // Initialize the timer
; 285  :     if( FALSE == m_bTimerInitialized )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
  00025	75 3c		 jne	 SHORT $L72670

; 286  :     {
; 287  :         m_bTimerInitialized = TRUE;

  00027	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 288  : 
; 289  :         // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
; 290  :         // not supported, we will timeGetTime() which returns milliseconds.
; 291  :         LARGE_INTEGER qwTicksPerSec;
; 292  :         m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );

  00031	8b f4		 mov	 esi, esp
  00033	8d 45 f0	 lea	 eax, DWORD PTR _qwTicksPerSec$72671[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	a3 00 00 00 00	 mov	 DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, eax

; 293  :         if( m_bUsingQPF )

  00049	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
  00050	74 11		 je	 SHORT $L72670

; 294  :             m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;

  00052	8b 45 f0	 mov	 eax, DWORD PTR _qwTicksPerSec$72671[ebp]
  00055	a3 00 00 00 00	 mov	 DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _qwTicksPerSec$72671[ebp+4]
  0005d	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx
$L72670:

; 295  :     }
; 296  : 
; 297  :     if( m_bUsingQPF )

  00063	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
  0006a	0f 84 49 02 00
	00		 je	 $L72673

; 298  :     {
; 299  :         static LONGLONG m_llStopTime        = 0;
; 300  :         static LONGLONG m_llLastElapsedTime = 0;
; 301  :         static LONGLONG m_llBaseTime        = 0;
; 302  :         double fTime;
; 303  :         double fElapsedTime;
; 304  :         LARGE_INTEGER qwTime;
; 305  :         
; 306  :         // Get either the current time or the stop time, depending
; 307  :         // on whether we're stopped and what command was sent
; 308  :         if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  00075	0b 05 04 00 00
	00		 or	 eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  0007b	85 c0		 test	 eax, eax
  0007d	74 1f		 je	 SHORT $L72683
  0007f	83 7d 08 01	 cmp	 DWORD PTR _command$[ebp], 1
  00083	74 19		 je	 SHORT $L72683
  00085	83 7d 08 04	 cmp	 DWORD PTR _command$[ebp], 4
  00089	74 13		 je	 SHORT $L72683

; 309  :             qwTime.QuadPart = m_llStopTime;

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  00090	89 45 c0	 mov	 DWORD PTR _qwTime$72682[ebp], eax
  00093	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  00099	89 4d c4	 mov	 DWORD PTR _qwTime$72682[ebp+4], ecx

; 310  :         else

  0009c	eb 13		 jmp	 SHORT $L72684
$L72683:

; 311  :             QueryPerformanceCounter( &qwTime );

  0009e	8b f4		 mov	 esi, esp
  000a0	8d 45 c0	 lea	 eax, DWORD PTR _qwTime$72682[ebp]
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L72684:

; 312  : 
; 313  :         // Return the elapsed time
; 314  :         if( command == TIMER_GETELAPSEDTIME )

  000b1	83 7d 08 06	 cmp	 DWORD PTR _command$[ebp], 6
  000b5	75 4e		 jne	 SHORT $L72685

; 315  :         {
; 316  :             fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;

  000b7	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  000ba	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  000c0	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  000c3	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  000c9	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  000cf	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv174[ebp+4], ecx
  000d5	df ad c4 fe ff
	ff		 fild	 QWORD PTR tv174[ebp]
  000db	df 2d 00 00 00
	00		 fild	 QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  000e1	de f9		 fdivp	 ST(1), ST(0)
  000e3	dd 5d d0	 fstp	 QWORD PTR _fElapsedTime$72681[ebp]

; 317  :             m_llLastElapsedTime = qwTime.QuadPart;

  000e6	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  000e9	a3 00 00 00 00	 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  000ee	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  000f1	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 318  :             return (FLOAT) fElapsedTime;

  000f7	dd 45 d0	 fld	 QWORD PTR _fElapsedTime$72681[ebp]
  000fa	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv180[ebp]
  00100	e9 7c 03 00 00	 jmp	 $L72661
$L72685:

; 319  :         }
; 320  :     
; 321  :         // Return the current time
; 322  :         if( command == TIMER_GETAPPTIME )

  00105	83 7d 08 05	 cmp	 DWORD PTR _command$[ebp], 5
  00109	75 3d		 jne	 SHORT $L72689

; 323  :         {
; 324  :             double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;

  0010b	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  0010e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  00114	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  00117	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  0011d	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  00123	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv186[ebp+4], ecx
  00129	df ad c4 fe ff
	ff		 fild	 QWORD PTR tv186[ebp]
  0012f	df 2d 00 00 00
	00		 fild	 QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  00135	de f9		 fdivp	 ST(1), ST(0)
  00137	dd 5d b0	 fstp	 QWORD PTR _fAppTime$72690[ebp]

; 325  :             return (FLOAT) fAppTime;

  0013a	dd 45 b0	 fld	 QWORD PTR _fAppTime$72690[ebp]
  0013d	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv190[ebp]
  00143	e9 39 03 00 00	 jmp	 $L72661
$L72689:

; 326  :         }
; 327  :     
; 328  :         // Reset the timer
; 329  :         if( command == TIMER_RESET )

  00148	83 7d 08 00	 cmp	 DWORD PTR _command$[ebp], 0
  0014c	75 4b		 jne	 SHORT $L72694

; 330  :         {
; 331  :             m_llBaseTime        = qwTime.QuadPart;

  0014e	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  00151	a3 00 00 00 00	 mov	 DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  00156	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  00159	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 332  :             m_llLastElapsedTime = qwTime.QuadPart;

  0015f	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  00162	a3 00 00 00 00	 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  00167	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  0016a	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 333  :             m_llStopTime        = 0;

  00170	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, 0
  0017a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, 0

; 334  :             m_bTimerStopped     = FALSE;

  00184	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 335  :             return 0.0f;

  0018e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00194	e9 e8 02 00 00	 jmp	 $L72661
$L72694:

; 336  :         }
; 337  :     
; 338  :         // Start the timer
; 339  :         if( command == TIMER_START )

  00199	83 7d 08 01	 cmp	 DWORD PTR _command$[ebp], 1
  0019d	75 6f		 jne	 SHORT $L72695

; 340  :         {
; 341  :             if( m_bTimerStopped )

  0019f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
  001a6	74 2c		 je	 SHORT $L72696

; 342  :                 m_llBaseTime += qwTime.QuadPart - m_llStopTime;

  001a8	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  001ab	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  001b1	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  001b4	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  001c0	03 d0		 add	 edx, eax
  001c2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  001c7	13 c1		 adc	 eax, ecx
  001c9	89 15 00 00 00
	00		 mov	 DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, edx
  001cf	a3 04 00 00 00	 mov	 DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, eax
$L72696:

; 343  :             m_llStopTime = 0;

  001d4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, 0
  001de	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, 0

; 344  :             m_llLastElapsedTime = qwTime.QuadPart;

  001e8	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  001eb	a3 00 00 00 00	 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  001f0	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  001f3	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 345  :             m_bTimerStopped = FALSE;

  001f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 346  :             return 0.0f;

  00203	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00209	e9 73 02 00 00	 jmp	 $L72661
$L72695:

; 347  :         }
; 348  :     
; 349  :         // Stop the timer
; 350  :         if( command == TIMER_STOP )

  0020e	83 7d 08 02	 cmp	 DWORD PTR _command$[ebp], 2
  00212	75 37		 jne	 SHORT $L72697

; 351  :         {
; 352  :             m_llStopTime = qwTime.QuadPart;

  00214	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  00217	a3 00 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  0021c	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  0021f	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 353  :             m_llLastElapsedTime = qwTime.QuadPart;

  00225	8b 45 c0	 mov	 eax, DWORD PTR _qwTime$72682[ebp]
  00228	a3 00 00 00 00	 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
  0022d	8b 4d c4	 mov	 ecx, DWORD PTR _qwTime$72682[ebp+4]
  00230	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 354  :             m_bTimerStopped = TRUE;

  00236	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 355  :             return 0.0f;

  00240	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00246	e9 36 02 00 00	 jmp	 $L72661
$L72697:

; 356  :         }
; 357  :     
; 358  :         // Advance the timer by 1/10th second
; 359  :         if( command == TIMER_ADVANCE )

  0024b	83 7d 08 03	 cmp	 DWORD PTR _command$[ebp], 3
  0024f	75 3b		 jne	 SHORT $L72698

; 360  :         {
; 361  :             m_llStopTime += m_llQPFTicksPerSec/10;

  00251	6a 00		 push	 0
  00253	6a 0a		 push	 10			; 0000000aH
  00255	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  0025a	50		 push	 eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  00261	51		 push	 ecx
  00262	e8 00 00 00 00	 call	 __alldiv
  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  0026d	03 c8		 add	 ecx, eax
  0026f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
  00274	13 c2		 adc	 eax, edx
  00276	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, ecx
  0027c	a3 04 00 00 00	 mov	 DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, eax

; 362  :             return 0.0f;

  00281	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00287	e9 f5 01 00 00	 jmp	 $L72661
$L72698:

; 363  :         }
; 364  : 
; 365  :         if( command == TIMER_GETABSOLUTETIME )

  0028c	83 7d 08 04	 cmp	 DWORD PTR _command$[ebp], 4
  00290	75 1c		 jne	 SHORT $L72699

; 366  :         {
; 367  :             fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;

  00292	df 6d c0	 fild	 QWORD PTR _qwTime$72682[ebp]
  00295	df 2d 00 00 00
	00		 fild	 QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
  0029b	de f9		 fdivp	 ST(1), ST(0)
  0029d	dd 5d e0	 fstp	 QWORD PTR _fTime$72680[ebp]

; 368  :             return (FLOAT) fTime;

  002a0	dd 45 e0	 fld	 QWORD PTR _fTime$72680[ebp]
  002a3	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv230[ebp]
  002a9	e9 d3 01 00 00	 jmp	 $L72661
$L72699:

; 369  :         }
; 370  : 
; 371  :         return -1.0f; // Invalid command specified

  002ae	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  002b4	e9 c8 01 00 00	 jmp	 $L72661
$L72673:

; 372  :     }
; 373  :     else
; 374  :     {
; 375  :         // Get the time using timeGetTime()
; 376  :         static double m_fLastElapsedTime  = 0.0;
; 377  :         static double m_fBaseTime         = 0.0;
; 378  :         static double m_fStopTime         = 0.0;
; 379  :         double fTime;
; 380  :         double fElapsedTime;
; 381  :         
; 382  :         // Get either the current time or the stop time, depending
; 383  :         // on whether we're stopped and what command was sent
; 384  :         if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

  002b9	dd 05 00 00 00
	00		 fld	 QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  002bf	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  002c5	df e0		 fnstsw	 ax
  002c7	f6 c4 44	 test	 ah, 68			; 00000044H
  002ca	7b 1f		 jnp	 SHORT $L72711
  002cc	83 7d 08 01	 cmp	 DWORD PTR _command$[ebp], 1
  002d0	74 19		 je	 SHORT $L72711
  002d2	83 7d 08 04	 cmp	 DWORD PTR _command$[ebp], 4
  002d6	74 13		 je	 SHORT $L72711

; 385  :             fTime = m_fStopTime;

  002d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  002dd	89 45 a0	 mov	 DWORD PTR _fTime$72709[ebp], eax
  002e0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4
  002e6	89 4d a4	 mov	 DWORD PTR _fTime$72709[ebp+4], ecx

; 386  :         else

  002e9	eb 2e		 jmp	 SHORT $L72712
$L72711:

; 387  :             fTime = timeGetTime() * 0.001;

  002eb	8b f4		 mov	 esi, esp
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  002f3	3b f4		 cmp	 esi, esp
  002f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fa	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
  00300	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv240[ebp+4], 0
  0030a	df ad c4 fe ff
	ff		 fild	 QWORD PTR tv240[ebp]
  00310	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f50624dd2f1a9fc
  00316	dd 5d a0	 fstp	 QWORD PTR _fTime$72709[ebp]
$L72712:

; 388  :     
; 389  :         // Return the elapsed time
; 390  :         if( command == TIMER_GETELAPSEDTIME )

  00319	83 7d 08 06	 cmp	 DWORD PTR _command$[ebp], 6
  0031d	75 2b		 jne	 SHORT $L72713

; 391  :         {   
; 392  :             fElapsedTime = (double) (fTime - m_fLastElapsedTime);

  0031f	dd 45 a0	 fld	 QWORD PTR _fTime$72709[ebp]
  00322	dc 25 00 00 00
	00		 fsub	 QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  00328	dd 5d 90	 fstp	 QWORD PTR _fElapsedTime$72710[ebp]

; 393  :             m_fLastElapsedTime = fTime;

  0032b	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  0032e	a3 00 00 00 00	 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  00333	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  00336	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 394  :             return (FLOAT) fElapsedTime;

  0033c	dd 45 90	 fld	 QWORD PTR _fElapsedTime$72710[ebp]
  0033f	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv247[ebp]
  00345	e9 37 01 00 00	 jmp	 $L72661
$L72713:

; 395  :         }
; 396  :     
; 397  :         // Return the current time
; 398  :         if( command == TIMER_GETAPPTIME )

  0034a	83 7d 08 05	 cmp	 DWORD PTR _command$[ebp], 5
  0034e	75 14		 jne	 SHORT $L72716

; 399  :         {
; 400  :             return (FLOAT) (fTime - m_fBaseTime);

  00350	dd 45 a0	 fld	 QWORD PTR _fTime$72709[ebp]
  00353	dc 25 00 00 00
	00		 fsub	 QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  00359	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv249[ebp]
  0035f	e9 1d 01 00 00	 jmp	 $L72661
$L72716:

; 401  :         }
; 402  :     
; 403  :         // Reset the timer
; 404  :         if( command == TIMER_RESET )

  00364	83 7d 08 00	 cmp	 DWORD PTR _command$[ebp], 0
  00368	75 4b		 jne	 SHORT $L72718

; 405  :         {
; 406  :             m_fBaseTime         = fTime;

  0036a	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  0036d	a3 00 00 00 00	 mov	 DWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  00372	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  00375	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 407  :             m_fLastElapsedTime  = fTime;

  0037b	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  0037e	a3 00 00 00 00	 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  00383	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  00386	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 408  :             m_fStopTime         = 0;

  0038c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, 0
  00396	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, 0

; 409  :             m_bTimerStopped     = FALSE;

  003a0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 410  :             return 0.0f;

  003aa	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  003b0	e9 cc 00 00 00	 jmp	 $L72661
$L72718:

; 411  :         }
; 412  :     
; 413  :         // Start the timer
; 414  :         if( command == TIMER_START )

  003b5	83 7d 08 01	 cmp	 DWORD PTR _command$[ebp], 1
  003b9	75 55		 jne	 SHORT $L72719

; 415  :         {
; 416  :             if( m_bTimerStopped )

  003bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
  003c2	74 15		 je	 SHORT $L72720

; 417  :                 m_fBaseTime += fTime - m_fStopTime;

  003c4	dd 45 a0	 fld	 QWORD PTR _fTime$72709[ebp]
  003c7	dc 25 00 00 00
	00		 fsub	 QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  003cd	dc 05 00 00 00
	00		 fadd	 QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  003d3	dd 1d 00 00 00
	00		 fstp	 QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
$L72720:

; 418  :             m_fStopTime = 0.0f;

  003d9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, 0
  003e3	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, 0

; 419  :             m_fLastElapsedTime  = fTime;

  003ed	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  003f0	a3 00 00 00 00	 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  003f5	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  003f8	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 420  :             m_bTimerStopped = FALSE;

  003fe	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 421  :             return 0.0f;

  00408	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0040e	eb 71		 jmp	 SHORT $L72661
$L72719:

; 422  :         }
; 423  :     
; 424  :         // Stop the timer
; 425  :         if( command == TIMER_STOP )

  00410	83 7d 08 02	 cmp	 DWORD PTR _command$[ebp], 2
  00414	75 34		 jne	 SHORT $L72721

; 426  :         {
; 427  :             m_fStopTime = fTime;

  00416	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  00419	a3 00 00 00 00	 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  0041e	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  00421	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 428  :             m_fLastElapsedTime  = fTime;

  00427	8b 45 a0	 mov	 eax, DWORD PTR _fTime$72709[ebp]
  0042a	a3 00 00 00 00	 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, eax
  0042f	8b 4d a4	 mov	 ecx, DWORD PTR _fTime$72709[ebp+4]
  00432	89 0d 04 00 00
	00		 mov	 DWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA+4, ecx

; 429  :             m_bTimerStopped = TRUE;

  00438	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 430  :             return 0.0f;

  00442	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00448	eb 37		 jmp	 SHORT $L72661
$L72721:

; 431  :         }
; 432  :     
; 433  :         // Advance the timer by 1/10th second
; 434  :         if( command == TIMER_ADVANCE )

  0044a	83 7d 08 03	 cmp	 DWORD PTR _command$[ebp], 3
  0044e	75 1a		 jne	 SHORT $L72722

; 435  :         {
; 436  :             m_fStopTime += 0.1f;

  00450	dd 05 00 00 00
	00		 fld	 QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
  00456	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fb99999a0000000
  0045c	dd 1d 00 00 00
	00		 fstp	 QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 437  :             return 0.0f;

  00462	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00468	eb 17		 jmp	 SHORT $L72661
$L72722:

; 438  :         }
; 439  : 
; 440  :         if( command == TIMER_GETABSOLUTETIME )

  0046a	83 7d 08 04	 cmp	 DWORD PTR _command$[ebp], 4
  0046e	75 0b		 jne	 SHORT $L72723

; 441  :         {
; 442  :             return (FLOAT) fTime;

  00470	dd 45 a0	 fld	 QWORD PTR _fTime$72709[ebp]
  00473	d9 95 c8 fe ff
	ff		 fst	 DWORD PTR tv263[ebp]
  00479	eb 06		 jmp	 SHORT $L72661
$L72723:

; 443  :         }
; 444  : 
; 445  :         return -1.0f; // Invalid command specified

  0047b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
$L72661:

; 446  :     }
; 447  : }

  00481	52		 push	 edx
  00482	8b cd		 mov	 ecx, ebp
  00484	50		 push	 eax
  00485	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72943
  0048b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00490	58		 pop	 eax
  00491	5a		 pop	 edx
  00492	5f		 pop	 edi
  00493	5e		 pop	 esi
  00494	5b		 pop	 ebx
  00495	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  0049b	3b ec		 cmp	 ebp, esp
  0049d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a2	8b e5		 mov	 esp, ebp
  004a4	5d		 pop	 ebp
  004a5	c2 04 00	 ret	 4
$L72943:
  004a8	02 00 00 00	 DD	 2
  004ac	00 00 00 00	 DD	 $L72942
$L72942:
  004b0	f0 ff ff ff	 DD	 -16			; fffffff0H
  004b4	08 00 00 00	 DD	 8
  004b8	00 00 00 00	 DD	 $L72940
  004bc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  004c0	08 00 00 00	 DD	 8
  004c4	00 00 00 00	 DD	 $L72941
$L72941:
  004c8	71		 DB	 113			; 00000071H
  004c9	77		 DB	 119			; 00000077H
  004ca	54		 DB	 84			; 00000054H
  004cb	69		 DB	 105			; 00000069H
  004cc	6d		 DB	 109			; 0000006dH
  004cd	65		 DB	 101			; 00000065H
  004ce	00		 DB	 0
$L72940:
  004cf	71		 DB	 113			; 00000071H
  004d0	77		 DB	 119			; 00000077H
  004d1	54		 DB	 84			; 00000054H
  004d2	69		 DB	 105			; 00000069H
  004d3	63		 DB	 99			; 00000063H
  004d4	6b		 DB	 107			; 0000006bH
  004d5	73		 DB	 115			; 00000073H
  004d6	50		 DB	 80			; 00000050H
  004d7	65		 DB	 101			; 00000065H
  004d8	72		 DB	 114			; 00000072H
  004d9	53		 DB	 83			; 00000053H
  004da	65		 DB	 101			; 00000065H
  004db	63		 DB	 99			; 00000063H
  004dc	00		 DB	 0
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z ENDP		; DXUtil_Timer
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z	; DXUtil_ConvertAnsiStringToWide
EXTRN	__imp__MultiByteToWideChar@24:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z
_TEXT	SEGMENT
_wstrDestination$ = 8
_strSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z PROC NEAR	; DXUtil_ConvertAnsiStringToWide, COMDAT

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 461  :     if( wstrDestination==NULL || strSource==NULL )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _wstrDestination$[ebp], 0
  00022	74 06		 je	 SHORT $L72731
  00024	83 7d 0c 00	 cmp	 DWORD PTR _strSource$[ebp], 0
  00028	75 02		 jne	 SHORT $L72730
$L72731:

; 462  :         return;

  0002a	eb 49		 jmp	 SHORT $L72729
$L72730:

; 463  : 
; 464  :     if( cchDestChar == -1 )

  0002c	83 7d 10 ff	 cmp	 DWORD PTR _cchDestChar$[ebp], -1
  00030	75 12		 jne	 SHORT $L72732

; 465  :         cchDestChar = strlen(strSource)+1;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _strSource$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _strlen
  0003b	83 c4 04	 add	 esp, 4
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 10	 mov	 DWORD PTR _cchDestChar$[ebp], eax
$L72732:

; 466  : 
; 467  :     MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
; 468  :                          wstrDestination, cchDestChar-1 );

  00044	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  00047	83 e8 01	 sub	 eax, 1
  0004a	8b f4		 mov	 esi, esp
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _wstrDestination$[ebp]
  00050	51		 push	 ecx
  00051	6a ff		 push	 -1
  00053	8b 55 0c	 mov	 edx, DWORD PTR _strSource$[ebp]
  00056	52		 push	 edx
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 469  : 
; 470  :     wstrDestination[cchDestChar-1] = 0;

  00068	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _wstrDestination$[ebp]
  0006e	66 c7 44 41 fe
	00 00		 mov	 WORD PTR [ecx+eax*2-2], 0
$L72729:

; 471  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToWide
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z	; DXUtil_ConvertWideStringToAnsi
EXTRN	_wcslen:NEAR
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z
_TEXT	SEGMENT
_strDestination$ = 8
_wstrSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z PROC NEAR	; DXUtil_ConvertWideStringToAnsi, COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 485  :     if( strDestination==NULL || wstrSource==NULL )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _strDestination$[ebp], 0
  00022	74 06		 je	 SHORT $L72739
  00024	83 7d 0c 00	 cmp	 DWORD PTR _wstrSource$[ebp], 0
  00028	75 02		 jne	 SHORT $L72738
$L72739:

; 486  :         return;

  0002a	eb 4a		 jmp	 SHORT $L72737
$L72738:

; 487  : 
; 488  :     if( cchDestChar == -1 )

  0002c	83 7d 10 ff	 cmp	 DWORD PTR _cchDestChar$[ebp], -1
  00030	75 12		 jne	 SHORT $L72740

; 489  :         cchDestChar = wcslen(wstrSource)+1;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _wstrSource$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _wcslen
  0003b	83 c4 04	 add	 esp, 4
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 10	 mov	 DWORD PTR _cchDestChar$[ebp], eax
$L72740:

; 490  : 
; 491  :     WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
; 492  :                          cchDestChar-1, NULL, NULL );

  00044	8b f4		 mov	 esi, esp
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  0004d	83 e8 01	 sub	 eax, 1
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _strDestination$[ebp]
  00054	51		 push	 ecx
  00055	6a ff		 push	 -1
  00057	8b 55 0c	 mov	 edx, DWORD PTR _wstrSource$[ebp]
  0005a	52		 push	 edx
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 493  : 
; 494  :     strDestination[cchDestChar-1] = 0;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _strDestination$[ebp]
  0006f	03 45 10	 add	 eax, DWORD PTR _cchDestChar$[ebp]
  00072	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
$L72737:

; 495  : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z ENDP	; DXUtil_ConvertWideStringToAnsi
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ; DXUtil_ConvertGenericStringToAnsi
EXTRN	_strncpy:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z
_TEXT	SEGMENT
_strDestination$ = 8
_tstrSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z PROC NEAR ; DXUtil_ConvertGenericStringToAnsi, COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 509  :     if( strDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _strDestination$[ebp], 0
  00022	74 0c		 je	 SHORT $L72747
  00024	83 7d 0c 00	 cmp	 DWORD PTR _tstrSource$[ebp], 0
  00028	74 06		 je	 SHORT $L72747
  0002a	83 7d 10 00	 cmp	 DWORD PTR _cchDestChar$[ebp], 0
  0002e	75 02		 jne	 SHORT $L72746
$L72747:

; 510  :         return;

  00030	eb 36		 jmp	 SHORT $L72745
$L72746:

; 511  : 
; 512  : #ifdef _UNICODE
; 513  :     DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
; 514  : #else
; 515  :     if( cchDestChar == -1 )

  00032	83 7d 10 ff	 cmp	 DWORD PTR _cchDestChar$[ebp], -1
  00036	75 12		 jne	 SHORT $L72748

; 516  :     {
; 517  :         strcpy( strDestination, tstrSource );

  00038	8b 45 0c	 mov	 eax, DWORD PTR _tstrSource$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _strDestination$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _strcpy
  00045	83 c4 08	 add	 esp, 8

; 518  :     }
; 519  :     else

  00048	eb 1e		 jmp	 SHORT $L72745
$L72748:

; 520  :     {
; 521  :         strncpy( strDestination, tstrSource, cchDestChar );

  0004a	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _tstrSource$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _strDestination$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 _strncpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 522  :         strDestination[cchDestChar-1] = '\0';

  0005e	8b 45 08	 mov	 eax, DWORD PTR _strDestination$[ebp]
  00061	03 45 10	 add	 eax, DWORD PTR _cchDestChar$[ebp]
  00064	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
$L72745:

; 523  :     }
; 524  : #endif
; 525  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertGenericStringToAnsi
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertGenericStringToWide@@YAXPAGPBDH@Z ; DXUtil_ConvertGenericStringToWide
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertGenericStringToWide@@YAXPAGPBDH@Z
_TEXT	SEGMENT
_wstrDestination$ = 8
_tstrSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertGenericStringToWide@@YAXPAGPBDH@Z PROC NEAR ; DXUtil_ConvertGenericStringToWide, COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 539  :     if( wstrDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _wstrDestination$[ebp], 0
  00022	74 0c		 je	 SHORT $L72756
  00024	83 7d 0c 00	 cmp	 DWORD PTR _tstrSource$[ebp], 0
  00028	74 06		 je	 SHORT $L72756
  0002a	83 7d 10 00	 cmp	 DWORD PTR _cchDestChar$[ebp], 0
  0002e	75 02		 jne	 SHORT $L72755
$L72756:

; 540  :         return;

  00030	eb 14		 jmp	 SHORT $L72754
$L72755:

; 541  : 
; 542  : #ifdef _UNICODE
; 543  :     if( cchDestChar == -1 )
; 544  :     {
; 545  :         wcscpy( wstrDestination, tstrSource );
; 546  :     }
; 547  :     else
; 548  :     {
; 549  :         wcsncpy( wstrDestination, tstrSource, cchDestChar );
; 550  :         wstrDestination[cchDestChar-1] = L'\0';
; 551  :     }
; 552  : #else
; 553  :     DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );

  00032	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _tstrSource$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _wstrDestination$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?DXUtil_ConvertAnsiStringToWide@@YAXPAGPBDH@Z ; DXUtil_ConvertAnsiStringToWide
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72754:

; 554  : #endif
; 555  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?DXUtil_ConvertGenericStringToWide@@YAXPAGPBDH@Z ENDP	; DXUtil_ConvertGenericStringToWide
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ; DXUtil_ConvertAnsiStringToGeneric
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z
_TEXT	SEGMENT
_tstrDestination$ = 8
_strSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z PROC NEAR ; DXUtil_ConvertAnsiStringToGeneric, COMDAT

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 569  :     if( tstrDestination==NULL || strSource==NULL || cchDestChar == 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _tstrDestination$[ebp], 0
  00022	74 0c		 je	 SHORT $L72763
  00024	83 7d 0c 00	 cmp	 DWORD PTR _strSource$[ebp], 0
  00028	74 06		 je	 SHORT $L72763
  0002a	83 7d 10 00	 cmp	 DWORD PTR _cchDestChar$[ebp], 0
  0002e	75 02		 jne	 SHORT $L72762
$L72763:

; 570  :         return;

  00030	eb 36		 jmp	 SHORT $L72761
$L72762:

; 571  :         
; 572  : #ifdef _UNICODE
; 573  :     DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
; 574  : #else
; 575  :     if( cchDestChar == -1 )

  00032	83 7d 10 ff	 cmp	 DWORD PTR _cchDestChar$[ebp], -1
  00036	75 12		 jne	 SHORT $L72764

; 576  :     {
; 577  :         strcpy( tstrDestination, strSource );

  00038	8b 45 0c	 mov	 eax, DWORD PTR _strSource$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _tstrDestination$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _strcpy
  00045	83 c4 08	 add	 esp, 8

; 578  :     }
; 579  :     else

  00048	eb 1e		 jmp	 SHORT $L72761
$L72764:

; 580  :     {
; 581  :         strncpy( tstrDestination, strSource, cchDestChar );

  0004a	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _strSource$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _tstrDestination$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 _strncpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 582  :         tstrDestination[cchDestChar-1] = '\0';

  0005e	8b 45 08	 mov	 eax, DWORD PTR _tstrDestination$[ebp]
  00061	03 45 10	 add	 eax, DWORD PTR _cchDestChar$[ebp]
  00064	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0
$L72761:

; 583  :     }
; 584  : #endif
; 585  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToGeneric
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertWideStringToGeneric@@YAXPADPBGH@Z ; DXUtil_ConvertWideStringToGeneric
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertWideStringToGeneric@@YAXPADPBGH@Z
_TEXT	SEGMENT
_tstrDestination$ = 8
_wstrSource$ = 12
_cchDestChar$ = 16
?DXUtil_ConvertWideStringToGeneric@@YAXPADPBGH@Z PROC NEAR ; DXUtil_ConvertWideStringToGeneric, COMDAT

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 599  :     if( tstrDestination==NULL || wstrSource==NULL || cchDestChar == 0 )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _tstrDestination$[ebp], 0
  00022	74 0c		 je	 SHORT $L72772
  00024	83 7d 0c 00	 cmp	 DWORD PTR _wstrSource$[ebp], 0
  00028	74 06		 je	 SHORT $L72772
  0002a	83 7d 10 00	 cmp	 DWORD PTR _cchDestChar$[ebp], 0
  0002e	75 02		 jne	 SHORT $L72771
$L72772:

; 600  :         return;

  00030	eb 14		 jmp	 SHORT $L72770
$L72771:

; 601  : 
; 602  : #ifdef _UNICODE
; 603  :     if( cchDestChar == -1 )
; 604  :     {
; 605  :         wcscpy( tstrDestination, wstrSource );
; 606  :     }
; 607  :     else
; 608  :     {
; 609  :         wcsncpy( tstrDestination, wstrSource, cchDestChar );
; 610  :         tstrDestination[cchDestChar-1] = L'\0';
; 611  :     }
; 612  : #else
; 613  :     DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );

  00032	8b 45 10	 mov	 eax, DWORD PTR _cchDestChar$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _wstrSource$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _tstrDestination$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?DXUtil_ConvertWideStringToAnsi@@YAXPADPBGH@Z ; DXUtil_ConvertWideStringToAnsi
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72770:

; 614  : #endif
; 615  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?DXUtil_ConvertWideStringToGeneric@@YAXPADPBGH@Z ENDP	; DXUtil_ConvertWideStringToGeneric
_TEXT	ENDS
PUBLIC	??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	?_DbgOut@@YAJPADKJ0@Z				; _DbgOut
EXTRN	__imp__OutputDebugStringA@4:NEAR
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@ DB '%s(%ld): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@ DB '(hr=%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?_DbgOut@@YAJPADKJ0@Z
_TEXT	SEGMENT
_buffer$ = -264
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_strFile$ = 8
_dwLine$ = 12
_hr$ = 16
_strMsg$ = 20
?_DbgOut@@YAJPADKJ0@Z PROC NEAR				; _DbgOut, COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-460]
  00012	b9 73 00 00 00	 mov	 ecx, 115		; 00000073H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 626  :     TCHAR buffer[256];
; 627  :     wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );

  00029	8b f4		 mov	 esi, esp
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _dwLine$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _strFile$[ebp]
  00032	51		 push	 ecx
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
  00038	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  0003e	52		 push	 edx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 628  :     OutputDebugString( buffer );

  0004f	8b f4		 mov	 esi, esp
  00051	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 629  :     OutputDebugString( strMsg );

  00065	8b f4		 mov	 esi, esp
  00067	8b 45 14	 mov	 eax, DWORD PTR _strMsg$[ebp]
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 630  : 
; 631  :     if( hr )

  00078	83 7d 10 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007c	74 38		 je	 SHORT $L72781

; 632  :     {
; 633  :         wsprintf( buffer, _T("(hr=%08lx)\n"), hr );

  0007e	8b f4		 mov	 esi, esp
  00080	8b 45 10	 mov	 eax, DWORD PTR _hr$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
  00089	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  0008f	51		 push	 ecx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 634  :         OutputDebugString( buffer );

  000a0	8b f4		 mov	 esi, esp
  000a2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  000a8	50		 push	 eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L72781:

; 635  :     }
; 636  : 
; 637  :     OutputDebugString( _T("\n") );

  000b6	8b f4		 mov	 esi, esp
  000b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 638  : 
; 639  :     return hr;

  000ca	8b 45 10	 mov	 eax, DWORD PTR _hr$[ebp]

; 640  : }

  000cd	52		 push	 edx
  000ce	8b cd		 mov	 ecx, ebp
  000d0	50		 push	 eax
  000d1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72963
  000d7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000dc	58		 pop	 eax
  000dd	5a		 pop	 edx
  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	81 c4 cc 01 00
	00		 add	 esp, 460		; 000001ccH
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$L72963:
  000fd	01 00 00 00	 DD	 1
  00101	00 00 00 00	 DD	 $L72962
$L72962:
  00105	f8 fe ff ff	 DD	 -264			; fffffef8H
  00109	00 01 00 00	 DD	 256			; 00000100H
  0010d	00 00 00 00	 DD	 $L72960
$L72960:
  00111	62		 DB	 98			; 00000062H
  00112	75		 DB	 117			; 00000075H
  00113	66		 DB	 102			; 00000066H
  00114	66		 DB	 102			; 00000066H
  00115	65		 DB	 101			; 00000065H
  00116	72		 DB	 114			; 00000072H
  00117	00		 DB	 0
?_DbgOut@@YAJPADKJ0@Z ENDP				; _DbgOut
_TEXT	ENDS
PUBLIC	?DXUtil_Trace@@YAXPADZZ				; DXUtil_Trace
EXTRN	__vsnprintf:NEAR
; Function compile flags: /Odt /RTCsu /ZI
;	COMDAT ?DXUtil_Trace@@YAXPADZZ
_TEXT	SEGMENT
_args$ = -532
_strBuffer$ = -520
__$ArrayPad$ = -4
__$ReturnAddr$ = 4
_strMsg$ = 8
?DXUtil_Trace@@YAXPADZZ PROC NEAR			; DXUtil_Trace, COMDAT

; 651  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 02 00
	00		 sub	 esp, 728		; 000002d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-728]
  00012	b9 b6 00 00 00	 mov	 ecx, 182		; 000000b6H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 45 04	 xor	 eax, DWORD PTR __$ReturnAddr$[ebp]
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 652  : #if defined(DEBUG) | defined(_DEBUG)
; 653  :     TCHAR strBuffer[512];
; 654  :     
; 655  :     va_list args;
; 656  :     va_start(args, strMsg);

  00029	8d 45 0c	 lea	 eax, DWORD PTR _strMsg$[ebp+4]
  0002c	89 85 ec fd ff
	ff		 mov	 DWORD PTR _args$[ebp], eax

; 657  :     _vsntprintf( strBuffer, 512, strMsg, args );

  00032	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _args$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _strMsg$[ebp]
  0003c	51		 push	 ecx
  0003d	68 00 02 00 00	 push	 512			; 00000200H
  00042	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _strBuffer$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 __vsnprintf
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 658  :     va_end(args);

  00051	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _args$[ebp], 0

; 659  : 
; 660  :     OutputDebugString( strBuffer );

  0005b	8b f4		 mov	 esi, esp
  0005d	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _strBuffer$[ebp]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 661  : #else
; 662  :     UNREFERENCED_PARAMETER(strMsg);
; 663  : #endif
; 664  : }

  00071	52		 push	 edx
  00072	8b cd		 mov	 ecx, ebp
  00074	50		 push	 eax
  00075	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72970
  0007b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00080	58		 pop	 eax
  00081	5a		 pop	 edx
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 4d 04	 xor	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	81 c4 d8 02 00
	00		 add	 esp, 728		; 000002d8H
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$L72970:
  000a1	01 00 00 00	 DD	 1
  000a5	00 00 00 00	 DD	 $L72969
$L72969:
  000a9	f8 fd ff ff	 DD	 -520			; fffffdf8H
  000ad	00 02 00 00	 DD	 512			; 00000200H
  000b1	00 00 00 00	 DD	 $L72967
$L72967:
  000b5	73		 DB	 115			; 00000073H
  000b6	74		 DB	 116			; 00000074H
  000b7	72		 DB	 114			; 00000072H
  000b8	42		 DB	 66			; 00000042H
  000b9	75		 DB	 117			; 00000075H
  000ba	66		 DB	 102			; 00000066H
  000bb	66		 DB	 102			; 00000066H
  000bc	65		 DB	 101			; 00000065H
  000bd	72		 DB	 114			; 00000072H
  000be	00		 DB	 0
?DXUtil_Trace@@YAXPADZZ ENDP				; DXUtil_Trace
_TEXT	ENDS
PUBLIC	??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ ; `string'
PUBLIC	?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z	; DXUtil_ConvertStringToGUID
EXTRN	_sscanf:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
CONST	SEGMENT
??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ DB '{'
	DB	'%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}', 00H ; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z
_TEXT	SEGMENT
_aiTmp$ = -44
_strIn$ = 8
_pGuidOut$ = 12
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z PROC NEAR ; DXUtil_ConvertStringToGUID, COMDAT

; 674  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 675  :     UINT aiTmp[10];
; 676  : 
; 677  :     if( _stscanf( strIn, TEXT("{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}"),
; 678  :                     &pGuidOut->Data1, 
; 679  :                     &aiTmp[0], &aiTmp[1], 
; 680  :                     &aiTmp[2], &aiTmp[3],
; 681  :                     &aiTmp[4], &aiTmp[5],
; 682  :                     &aiTmp[6], &aiTmp[7],
; 683  :                     &aiTmp[8], &aiTmp[9] ) != 11 )

  0001e	8d 45 f8	 lea	 eax, DWORD PTR _aiTmp$[ebp+36]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR _aiTmp$[ebp+32]
  00025	51		 push	 ecx
  00026	8d 55 f0	 lea	 edx, DWORD PTR _aiTmp$[ebp+28]
  00029	52		 push	 edx
  0002a	8d 45 ec	 lea	 eax, DWORD PTR _aiTmp$[ebp+24]
  0002d	50		 push	 eax
  0002e	8d 4d e8	 lea	 ecx, DWORD PTR _aiTmp$[ebp+20]
  00031	51		 push	 ecx
  00032	8d 55 e4	 lea	 edx, DWORD PTR _aiTmp$[ebp+16]
  00035	52		 push	 edx
  00036	8d 45 e0	 lea	 eax, DWORD PTR _aiTmp$[ebp+12]
  00039	50		 push	 eax
  0003a	8d 4d dc	 lea	 ecx, DWORD PTR _aiTmp$[ebp+8]
  0003d	51		 push	 ecx
  0003e	8d 55 d8	 lea	 edx, DWORD PTR _aiTmp$[ebp+4]
  00041	52		 push	 edx
  00042	8d 45 d4	 lea	 eax, DWORD PTR _aiTmp$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pGuidOut$[ebp]
  00049	51		 push	 ecx
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
  0004f	8b 55 08	 mov	 edx, DWORD PTR _strIn$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _sscanf
  00058	83 c4 34	 add	 esp, 52			; 00000034H
  0005b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0005e	74 14		 je	 SHORT $L72800

; 684  :     {
; 685  :         ZeroMemory( pGuidOut, sizeof(GUID) );

  00060	6a 10		 push	 16			; 00000010H
  00062	6a 00		 push	 0
  00064	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _memset
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 686  :         return FALSE;

  00070	33 c0		 xor	 eax, eax
  00072	eb 63		 jmp	 SHORT $L72798
$L72800:

; 687  :     }
; 688  :     else
; 689  :     {
; 690  :         pGuidOut->Data2       = (USHORT) aiTmp[0];

  00074	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  00077	66 8b 4d d4	 mov	 cx, WORD PTR _aiTmp$[ebp]
  0007b	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 691  :         pGuidOut->Data3       = (USHORT) aiTmp[1];

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  00082	66 8b 4d d8	 mov	 cx, WORD PTR _aiTmp$[ebp+4]
  00086	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 692  :         pGuidOut->Data4[0]    = (BYTE) aiTmp[2];

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  0008d	8a 4d dc	 mov	 cl, BYTE PTR _aiTmp$[ebp+8]
  00090	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 693  :         pGuidOut->Data4[1]    = (BYTE) aiTmp[3];

  00093	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  00096	8a 4d e0	 mov	 cl, BYTE PTR _aiTmp$[ebp+12]
  00099	88 48 09	 mov	 BYTE PTR [eax+9], cl

; 694  :         pGuidOut->Data4[2]    = (BYTE) aiTmp[4];

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  0009f	8a 4d e4	 mov	 cl, BYTE PTR _aiTmp$[ebp+16]
  000a2	88 48 0a	 mov	 BYTE PTR [eax+10], cl

; 695  :         pGuidOut->Data4[3]    = (BYTE) aiTmp[5];

  000a5	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  000a8	8a 4d e8	 mov	 cl, BYTE PTR _aiTmp$[ebp+20]
  000ab	88 48 0b	 mov	 BYTE PTR [eax+11], cl

; 696  :         pGuidOut->Data4[4]    = (BYTE) aiTmp[6];

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  000b1	8a 4d ec	 mov	 cl, BYTE PTR _aiTmp$[ebp+24]
  000b4	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 697  :         pGuidOut->Data4[5]    = (BYTE) aiTmp[7];

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  000ba	8a 4d f0	 mov	 cl, BYTE PTR _aiTmp$[ebp+28]
  000bd	88 48 0d	 mov	 BYTE PTR [eax+13], cl

; 698  :         pGuidOut->Data4[6]    = (BYTE) aiTmp[8];

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  000c3	8a 4d f4	 mov	 cl, BYTE PTR _aiTmp$[ebp+32]
  000c6	88 48 0e	 mov	 BYTE PTR [eax+14], cl

; 699  :         pGuidOut->Data4[7]    = (BYTE) aiTmp[9];

  000c9	8b 45 0c	 mov	 eax, DWORD PTR _pGuidOut$[ebp]
  000cc	8a 4d f8	 mov	 cl, BYTE PTR _aiTmp$[ebp+36]
  000cf	88 48 0f	 mov	 BYTE PTR [eax+15], cl

; 700  :         return TRUE;

  000d2	b8 01 00 00 00	 mov	 eax, 1
$L72798:

; 701  :     }
; 702  : }

  000d7	52		 push	 edx
  000d8	8b cd		 mov	 ecx, ebp
  000da	50		 push	 eax
  000db	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L72975
  000e1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e6	58		 pop	 eax
  000e7	5a		 pop	 edx
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
$L72975:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $L72974
$L72974:
  00104	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00108	28 00 00 00	 DD	 40			; 00000028H
  0010c	00 00 00 00	 DD	 $L72973
$L72973:
  00110	61		 DB	 97			; 00000061H
  00111	69		 DB	 105			; 00000069H
  00112	54		 DB	 84			; 00000054H
  00113	6d		 DB	 109			; 0000006dH
  00114	70		 DB	 112			; 00000070H
  00115	00		 DB	 0
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z ENDP	; DXUtil_ConvertStringToGUID
_TEXT	ENDS
PUBLIC	??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ ; `string'
PUBLIC	?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z	; DXUtil_ConvertGUIDToString
;	COMDAT ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
CONST	SEGMENT
??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ DB '{'
	DB	'%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}', 00H ; `string'
; Function compile flags: /Odt /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z
_TEXT	SEGMENT
_pGuidIn$ = 8
_strOut$ = 12
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z PROC NEAR ; DXUtil_ConvertGUIDToString, COMDAT

; 712  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 713  :     _stprintf( strOut, TEXT("{%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}"),
; 714  :                pGuidIn->Data1, pGuidIn->Data2, pGuidIn->Data3,
; 715  :                pGuidIn->Data4[0], pGuidIn->Data4[1],
; 716  :                pGuidIn->Data4[2], pGuidIn->Data4[3],
; 717  :                pGuidIn->Data4[4], pGuidIn->Data4[5],
; 718  :                pGuidIn->Data4[6], pGuidIn->Data4[7] );

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pGuidIn$[ebp]
  00021	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _pGuidIn$[ebp]
  00029	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _pGuidIn$[ebp]
  00031	0f b6 51 0d	 movzx	 edx, BYTE PTR [ecx+13]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _pGuidIn$[ebp]
  00039	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _pGuidIn$[ebp]
  00041	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pGuidIn$[ebp]
  00049	0f b6 51 0a	 movzx	 edx, BYTE PTR [ecx+10]
  0004d	52		 push	 edx
  0004e	8b 45 08	 mov	 eax, DWORD PTR _pGuidIn$[ebp]
  00051	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00055	51		 push	 ecx
  00056	8b 55 08	 mov	 edx, DWORD PTR _pGuidIn$[ebp]
  00059	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pGuidIn$[ebp]
  00061	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00065	52		 push	 edx
  00066	8b 45 08	 mov	 eax, DWORD PTR _pGuidIn$[ebp]
  00069	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0006d	51		 push	 ecx
  0006e	8b 55 08	 mov	 edx, DWORD PTR _pGuidIn$[ebp]
  00071	8b 02		 mov	 eax, DWORD PTR [edx]
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR _strOut$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 34	 add	 esp, 52			; 00000034H

; 719  : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z ENDP	; DXUtil_ConvertGUIDToString
_TEXT	ENDS
END
